Gambit
1 Introduction
2 Pairs and lists
  2.1 Overview of pairs and lists
  2.2 Pair and list jargon
  2.3 Pair and list procedures
General Index
Type Index
Index of procedures and syntactic forms
Gambit
******

Gambit is a portable, reliable, and efficient implementation of the
Scheme programming language.

   For the most up-to-date information on Gambit and related resources,
visit the Gambit home page (https://gambitscheme.org).  Please report
issues via the Gambit repository on GitHub
(https://github.com/gambit/gambit).

   This is the Revised report on Gambit (built October 08, 2024).  It
documents Gambit v4.9.5.

   Copyright © 1994-2022 Marc Feeley et al.

     The Gambit system, version 4.9.5, is licensed under two licenses:
     the Apache License, version 2.0 (https://www.apache.org/licenses/),
     and the GNU Lesser General Public License, version 2.1
     (https://www.gnu.org/licenses/).  You may choose which of these two
     licenses to abide by.

1 Introduction
**************

The Gambit programming system is a complete implementation of the Scheme
language aimed at portability, reliability, and speed.  It features two
main programs: ‘gsi’, the Gambit Scheme interpreter, and ‘gsc’, the
Gambit Scheme compiler.

   In its default configuration, Gambit provides a superset of the
language described by ‘The Revised^{7} Report on the Algorithmic
Language Scheme’, also known as R7RS.  Gambit may be configured to
conform to the R4RS, R5RS, R7RS, or IEEE 1178-1990 Scheme standards.

   gsi provides a subset of gsc's functionality.  The only difference
between these programs is that gsc also provides certain procedures and
invocation options specific to compilation.

   gsc compiles programs by “transpiling” Scheme source code to source
code for a target language, then optionally passing that transpiled code
to tools like gcc for further processing (*note (gcc)::).  Supported
target languages include C and JavaScript.

   The C target is the most mature, generating efficient C code that
lets Gambit run on any platform for which a C compiler is available.
With appropriate declarations in the Scheme source code (TODO: reference
goes here), the resulting programs run roughly as fast as functionally
equivalent programs built from hand-written C.

   Most of the Gambit system, including gsi and gsc itself, is written
in Scheme and compiled using gsc.

2 Pairs and lists
*****************

2.1 Overview of pairs and lists
===============================

This section may eventually provide introductory/high-level information
about pairs and lists.

2.2 Pair and list jargon
========================

 -- R7RS type: empty list
     The empty list is a unique object whose external representation is
     ‘()’.  Because the empty list is a unique object, it can never be
     newly allocated (TODO: reference goes here).  The predicate ‘null?’
     may be used to determine whether an object is the empty list (*note
     Pair and list procedures::).

     The empty list is a list.

 -- R7RS type: pair
     A pair is an object with two fields.  It is constructed by the
     ‘cons’ procedure; the content of its first field is selected by the
     ‘car’ procedure; the content of its second field is selected by the
     ‘cdr’ procedure.  The predicate ‘pair?’ may be used to determine
     whether an object is a pair (*note Pair and list procedures::).

     The first field of a pair is often referred to as its “car field”
     or just its “car”.  The second field of a pair is often referred to
     as its “cdr field” or just its “cdr”.

     “Take the car of p” means “use ‘car’ to select the first field of
     p”.  “Take the cdr of p” means “use ‘cdr’ to select the second
     field of p”.

     “Cons a onto b” means “use ‘cons’ to construct a pair whose first
     field contains a and whose second field contains b”.

     The empty list is not a pair.  A pair is a list if and only if its
     cdr is a list.

 -- R7RS type: list
     A list is either the empty list or a pair whose cdr is a list.
     This implies a list must have finite length and be terminated by
     the empty list.  The predicate ‘list?’ may be used to determine
     whether an object is a list (*note Pair and list procedures::).

     With the exception of the empty list, every list is a pair.

 -- colloquialism: proper list
     “Proper list” is a widely-used synonym for list (see above).
     Because it's a synonym, there's technically no need for the
     qualifier.  But in practice, people often refer to list-like
     objects that are not lists as “improper lists”.  The qualifier
     “proper” is therefore used to emphasize that an object is a Scheme
     list that satisfies ‘list?’.

 -- colloquialism: improper list
     “Improper list” is sometimes used to describe a pair whose cdr is
     not a list.  This means that, despite its name, an “improper list”
     is not a list under Scheme's formal definition.  In contexts where
     the term “improper list” appears, lists are often referred to as
     “proper lists” to emphasize the distinction.

 -- colloquialism: dotted pair
     “Dotted pair” is sometimes used as a synonym for pair.  “Dotted”
     refers to the common external representation of a pair in which the
     last element is preceded by a period (‘.’, which resembles a dot).
     This “dotted notation” may technically be used to represent any
     pair, but is typically used only to represent pairs that are not
     lists.

 -- colloquialism: association list
     An “association list” (or “alist”, for short) is a list of pairs.

2.3 Pair and list procedures
============================

 -- scheme/base: pair? obj
     Returns ‘#t’ if OBJ is a pair.

          (pair? '(a . b))  ⇒ #t
          (pair? '(a b c))  ⇒ #t
          (pair? '(() ()))  ⇒ #t
          (pair? '(#() ())) ⇒ #t
          (pair? '())       ⇒ #f
          (pair? '#(a b))   ⇒ #f

 -- scheme/base: cons obj1 obj2
     Returns a newly allocated pair whose car is OBJ1 and whose cdr is
     OBJ2.  The pair is guaranteed to be different (in the sense of
     ‘eqv?’) from every existing object.

          (cons 'a '())        ⇒ (a)
          (cons '(a) '(b c d)) ⇒ ((a) b c d)
          (cons "a" '(b c))    ⇒ ("a" b c)
          (cons 'a 3)          ⇒ (a . 3)
          (cons '(a b) 'c)     ⇒ ((a b) . c)

          (eqv?   (cons + car) (cons + car)) ⇒ #f
          (equal? (cons + car) (cons + car)) ⇒ #t
          (eq? cons (cdr (cons cons cons)))  ⇒ #t

          (cons)    → wrong-number-of-arguments exception
          (cons 'a) → wrong-number-of-arguments exception

 -- scheme/base: car pair
     Returns the contents of the cdr field of PAIR.  If an attempt is
     made to take the car of the empty list, an exception that satisfies
     ‘type-exception?’ is raised.

          (car '(a b c))     ⇒ a
          (car '((a) b c d)) ⇒ (a)
          (car '(1 . 2))     ⇒ 1

          (car '())      → type exception
          (car #(4 6 8)) → type exception

 -- scheme/base: cdr pair
     Returns the contents of the cdr field of PAIR.  If an attempt is
     made to take the cdr of the empty list, an exception that satisfies
     ‘type-exception?’ is raised.

          (cdr '(a b c))     ⇒ (b c)
          (cdr '((a) b c d)) ⇒ (b c d)
          (cdr '(1 . 2))     ⇒ 2

          (cdr '())      → type exception
          (cdr #(4 6 8)) → type exception

 -- scheme/base: set-car! pair obj
     Mutates PAIR by storing OBJ in the car field of PAIR.

          (define (f) (list 'not-a-constant-list))
          (set-car! (f) 3)
          (f) ⇒ (not-a-constant-list)

          (define (g) '(constant-list))
          (set-car! (g) 3) ;; R7RS says this is an error
          (g) ⇒ (3)        ;; current Gambit behavior

 -- scheme/base: set-cdr! pair obj
     Mutates PAIR by storing OBJ in the cdr field of PAIR.

          (define (f) (list 'not-a-constant-list))
          (set-cdr! (f) 3)
          (f) ⇒ (not-a-constant-list)

          (define (g) '(constant-list))
          (set-cdr! (g) 3)          ;; R7RS says this is an error
          (g) ⇒ (constant-list . 3) ;; current Gambit behavior

 -- scheme/cxr: caar pair
 -- scheme/cxr: cadr pair
 -- scheme/cxr: cdar pair
 -- scheme/cxr: cddr pair
 -- scheme/cxr: caaar pair
 -- scheme/cxr: caadr pair
 -- scheme/cxr: cadar pair
 -- scheme/cxr: caddr pair
 -- scheme/cxr: cdaar pair
 -- scheme/cxr: cdadr pair
 -- scheme/cxr: cddar pair
 -- scheme/cxr: cdddr pair
 -- scheme/cxr: caaaar pair
 -- scheme/cxr: caaadr pair
 -- scheme/cxr: caadar pair
 -- scheme/cxr: caaddr pair
 -- scheme/cxr: cadaar pair
 -- scheme/cxr: cadadr pair
 -- scheme/cxr: caddar pair
 -- scheme/cxr: cadddr pair
 -- scheme/cxr: cdaaar pair
 -- scheme/cxr: cdaadr pair
 -- scheme/cxr: cdadar pair
 -- scheme/cxr: cdaddr pair
 -- scheme/cxr: cddaar pair
 -- scheme/cxr: cddadr pair
 -- scheme/cxr: cdddar pair
 -- scheme/cxr: cddddr pair
     These 28 procedures are compositions of ‘car’ and ‘cdr’.

          (define l '((a b) (c) d (e (f) g)))
          (cadr l)             ⇒ (c)
          (car (cdr l))        ⇒ (c)
          (cddr '(a b c . d))  ⇒ (c . d)
          (cdddr '(a b c . d)) ⇒ d
          (cdadr l)            ⇒ ()
          (cdar (cdr l))       ⇒ ()
          (caar (cdr l))       ⇒ c
          (car (car (cdr l)))  ⇒ c
          (cadddr l)           ⇒ (e (f) g)

          (define circle (circular-list 'a 'b 'c))
          (car circle)    ⇒ a
          (cadr circle)   ⇒ b
          (caddr circle)  ⇒ c
          (cadddr circle) ⇒ a

          (cdar '(a . b))   → type exception
          (cddr (list #\f)) → type exception

 -- scheme/base: null? obj
     Returns ‘#t’ if OBJ is the empty list.

          (null? '())    ⇒ #t
          (null? '(  ))  ⇒ #t
          (null? (list)) ⇒ #t
          (null? #\null) ⇒ #f
          (null? #!eof)  ⇒ #f
          (null? #!void) ⇒ #f
          (null? #f)     ⇒ #f
          (null? 0)      ⇒ #f
          (null? "")     ⇒ #f
          (null? #())    ⇒ #f
          (null? #u8( )) ⇒ #f

 -- scheme/base: list? obj
 -- gambit/list: proper-list? obj
     Returns ‘#t’ if OBJ is a proper list (*note Pair and list
     jargon::).  By definition, a list of finite length is terminated by
     the empty list.

     ‘proper-list?’ is functionally equivalent to ‘list?’.

          (list? '(a b c))              ⇒ #t
          (list? '())                   ⇒ #t
          (list? (list 0))              ⇒ #t
          (list? '(a . b))              ⇒ #f
          (list? list)                  ⇒ #f
          (list? "list")                ⇒ #f
          (list? #(0 1 2))              ⇒ #f
          (list? (circular-list 0 1 2)) ⇒ #f

          (let ((x (list 'a)))
            (set-cdr! x x)
            (list? x)) ⇒ #f

 -- scheme/base: make-list k [fill]
     Returns a newly allocated list of K elements.  In the one-argument
     form, each element is initialized to a default value.  In the
     two-argument form, each element is initialized to FILL.

     The default value used by the one-argument form may change in a
     future version.  Programs that require a specific initialization
     value should use the two-argument form.

     If K is not an exact integer, an exception that satisfies
     ‘type-exception?’ is raised.  If K is a negative exact integer, an
     exception that satisfies ‘range-exception?’ is raised.

          (make-list 0)                        ⇒ ()
          (make-list 3 (list))                 ⇒ (() () ())
          (make-list 3 (vector))               ⇒ (#() #() #())
          (make-list 2 (make-list 2 (vector))) ⇒ ((#() #()) (#() #()))

          (make-list 1.25) → type exception
          (make-list -1)   → range exception

 -- scheme/base: list obj...
     Returns a newly allocated list consisting of its arguments.

          (list 'a (+ 3 4) 'c)         ⇒ (a 7 c)
          (list)                       ⇒ ()
          ((car (list list)) 'list)    ⇒ (list)
          (eqv? (list #\l) (list #\l)) ⇒ #f

          `(list ,(+ 1 2) 4)                     ⇒ (list 3 4)
          (let ((name 'a)) `(list ,name ',name)) ⇒ (list a (quote a))

 -- scheme/base: length list
     Returns the length of LIST.

          (define circle (circular-list 'x 'y 'z))
          (length '(a b c))            ⇒ 3
          (length '(a (b) (c d e)))    ⇒ 3
          (length '())                 ⇒ 0
          (length (cdr (make-list 5))) ⇒ 4
          (length circle)              → infinite loop

 -- scheme/base: append list... [obj]
     The zero-argument form returns the empty list.  The one-argument
     form returns its argument, whatever that argument's type.  Each
     argument except the last, if present, must be a list.

     With two or more arguments, the returned value consists of the
     elements of each LIST in order (excluding each LIST's terminating
     empty list).  A proper list is returned if OBJ is a proper list; an
     improper list is returned if if OBJ is not a proper list (*note
     Pair and list jargon::).  The returned value is newly allocated,
     except that it shares structure with the last argument, OBJ.

          (append '(x) '(y))       ⇒ (x y)
          (append '(a) '(b c d))   ⇒ (a b c d)
          (append '(a (b)) '((c))) ⇒ (a (b) (c))
          (append '(a b) '(c . d)) ⇒ (a b c . d) ;; lacking propriety
          (append '() 'a)          ⇒ a ;; egregiously lacking propriety

          (define l (list 'f 'g 'h))
          (eq?    l (append (append) l)) ⇒ #t
          (eq?    l (append l (append))) ⇒ #f
          (equal? l (append l (append))) ⇒ #t

 -- scheme/base: reverse list
     Returns a newly allocated list consisting of the elements of LIST
     in reverse order (excluding the terminating empty list).

          (reverse '(a b c))             ⇒ (c b a)
          (reverse '(a (b c) d (e (f)))) ⇒ ((e (f)) d (b c) a)

          (define l (list 'a 'b 'c))
          (eq?    l (reverse (reverse l))) ⇒ #f
          (equal? l (reverse (reverse l))) ⇒ #t

 -- scheme/base: list-tail list k
     Returns a copy of LIST obtained by omitting the first K elements.
     If LIST is a proper list, a proper list is returned; if LIST is an
     improper list, an improper list is returned (*note Pair and list
     jargon::).

     If K is not an exact integer, an exception that satisfies
     ‘type-exception?’ is raised.  If LIST has fewer than K elements, an
     exception that satisfies ‘range-exception?’ is raised.

          (list-tail '(a b c) 1)   ⇒ (b c)
          (list-tail '(a b c) 3)   ⇒ ()
          (list-tail '(a b . c) 1) ⇒ (b . c) ;; impropriety
          (list-tail '(a b . c) 2) ⇒ c ;; abject impropriety

          (list-tail '(a b c) 1.1) → type exception
          (list-tail '(a b c) 4)   → range exception

 -- scheme/base: list-ref list k
     Returns element K of LIST.  Equivalent to ‘(car (list-tail list
     k))’.  The LIST argument may be circular.

          (list-ref '(a b c d) 2)                   ⇒ c
          (list-ref '(a b c d) (exact (round 1.8))) ⇒ c

          (list-ref (circular-list 'a 'b) 3) ⇒ b ;; R7RS says this is an error

 -- scheme/base: list-set! list k obj
     Mutates LIST by storing OBJ in element K of LIST.  It is an error
     if K is not a valid index of LIST.

          (define ls (list 'one 'two 'five!))
          (list-set! ls 2 'three)
          ls ⇒ (one two three)

          (list-set! '(0 1 2) 1 "oops") ;; R7RS says this is an error

 -- scheme/base: memq obj list
 -- scheme/base: memv obj list
 -- scheme/base: member obj list [compare]
     Each procedure successively applies some test procedure to each
     element of LIST and returns the first sublist of LIST whose car
     satisfies that test procedure relative to OBJ.  They differ only in
     the test procedure that is used.  If no element of LIST satisfies
     the test, ‘#f’ is returned.

     In each two-argument form, a standard equivalence predicate is
     used.  In the three-argument form of ‘member’, COMPARE may return a
     non-Boolean value.

        • ‘memq’ uses ‘eq?’
        • ‘memv’ uses ‘eqv?’
        • ‘member’ uses ‘equal?’ in the two-argument form.
        • ‘member’ uses COMPARE in the three-argument form.

          (memq   101 '(100 101 102)) ⇒ (101 102) ;; R7RS: unspecified
          (memv   101 '(100 101 102)) ⇒ (101 102)
          (member 7 '(100 101 102) +) ⇒ (100 101 102)

          (memq   'a '(a b c))                    ⇒ (a b c)
          (memq   'a '(b c d))                    ⇒ #f
          (memq   (list 'a) '(b (a) c))           ⇒ #f
          (memq   'a '(a b c))                    ⇒ (a b c)
          (memv   'b '(a b c))                    ⇒ (b c)
          (memv   'b '(a b . c))                  ⇒ (b . c)
          (member 'b '(a b c) eq?)                ⇒ (b c)
          (member (list 'a) '(b (a) c))           ⇒ ((a) c)
          (member "B" '("a" "b" "c") string-ci=?) ⇒ ("b" "c")
          (member 7 '(7 8 9) (lambda x #f))       ⇒ #f

          (memv 'c '(a b . c))      → type exception
          (member 9 '(7 8 9) zero?) → wrong-number-of-arguments exception

 -- scheme/base: assq obj alist
 -- scheme/base: assv obj alist
 -- scheme/base: assoc obj alist [compare]
     Each of these procedures successively applies some test procedure
     to the elements of ALIST and returns the first pair of ALIST whose
     car satisfies that test procedure relative to OBJ ("alist" is short
     for "association list"; *note Pair and list jargon::).  They differ
     only in the test procedure that is used.  If none of ALIST's
     elements' cars satisfies the test, ‘#f’ is returned.

     In each two-argument form, a standard equivalence predicate is
     used.  In the three-argument form of ‘assoc’, COMPARE may return a
     non-Boolean value.

        • ‘assq’ uses ‘eq?’
        • ‘assv’ uses ‘eqv?’
        • ‘assoc’ uses ‘equal?’ in the two-argument form.
        • ‘assoc’ uses COMPARE in the three-argument form.

          (define p '((a 1) (b 2) (c 3)))
          (assq 'a p)                            ⇒ (a 1)
          (assq 'b p)                            ⇒ (b 2)
          (assv 'd p)                            ⇒ #f
          (assq (list 'a) '(((a)) ((b)) ((c))))  ⇒ #f
          (assoc (list 'a) '(((a)) ((b)) ((c)))) ⇒ ((a))
          (assoc 2.0 '((1 1) (2 4) (3 9)) =)     ⇒ (2 4)
          (assq 5 '((2 3) (5 7) (11 13)))        ⇒ (5 7) ;; R7RS: unspecified
          (assv 5 '((2 3) (5 7) (11 13)))        ⇒ (5 7)

          (define i '((a . 1) (b . 2) (c . 3)))
          (assq 'b i) ⇒ (a . 1)
          (assv 'c i) ⇒ (c . 3)
          (assq 'd p) ⇒ #f
          (assv 'b '((a . 1) (b . 2) . (c . 3))) ⇒ (b . 2)

          (assv 'c '((a . 1) (b . 2) . (c . 3))) → type exception

          (define dc '(("red"    . "rouge")
                       ("green"  . "vert")
                       ("blue"   . "bleu")
                       ("orange" . "orange")))

          (define (f e)
            (let ((f (assoc e dc string=?)))
              (and f (cdr f))))

          (f "green")  ⇒ "vert"
          (f "orange") ⇒ "orange"
          (f "purple") ⇒ #f

 -- scheme/base: list-copy obj
     Returns a newly allocated copy of the given OBJ if it is a list.
     Only the pairs themselves are copied; the cars of the result are
     the same (in the sense of ‘eqv?’) as the cars of LIST.  If OBJ is
     an improper list, so is the result, and the final cdrs are the same
     in the sense of ‘eqv?’.  An OBJ which is not a list is returned
     unchanged.  It is an error if OBJ is a circular list.

          (define a '(1 8 2 8))    ;; a may be immutable
          (define b (list-copy a))
          (set-car! b 3)           ;; b is mutable
          b ⇒ (3 8 2 8)
          a ⇒ (1 8 2 8)

          (list-copy '(a b . c))                           ⇒ (a b . c)
          (list-copy 'unchanged)                           ⇒ unchanged
          (eqv? '() (list-copy '()))                       ⇒ #t
          (eqv? list-copy ((lambda (x) x) list-copy))      ⇒ #t
          (eqv? (lambda (x) x) (list-copy (lambda (x) x))) ⇒ #f

          (define i (cons (string-copy "one") (string-copy "two")))
          (define p (cons (car i) (cons (cdr i) '())))
          (eqv? (cdr i) (cdr (list-copy i))) ⇒ #t
          (eqv? (cdr p) (cdr (list-copy p))) ⇒ #f

          (list-copy) → wrong-number-of-arguments exception

          (define c (circular-list 0 1 2))
          (circular-list? c) ⇒ #t
          (list-copy (circular-list 0 1 2)) → infinite loop

General Index
*************

* Menu:

* association list:                      Pair and list jargon.
                                                              (line 135)
* car:                                   Pair and list jargon.
                                                              (line  83)
* car, car field:                        Pair and list jargon.
                                                              (line  90)
* car, car procedure:                    Pair and list procedures.
                                                              (line 169)
* car, take the car:                     Pair and list jargon.
                                                              (line  94)
* cdr:                                   Pair and list jargon.
                                                              (line  83)
* cdr, cdr field:                        Pair and list jargon.
                                                              (line  90)
* cdr, cdr procedure:                    Pair and list procedures.
                                                              (line 181)
* cdr, take the cdr:                     Pair and list jargon.
                                                              (line  94)
* cons:                                  Pair and list jargon.
                                                              (line  83)
* cons, cons onto:                       Pair and list jargon.
                                                              (line  98)
* cons, cons procedure:                  Pair and list procedures.
                                                              (line 151)
* dotted pair:                           Pair and list jargon.
                                                              (line 127)
* gsc:                                   Introduction.        (line  34)
* gsi:                                   Introduction.        (line  34)
* improper list:                         Pair and list jargon.
                                                              (line 120)
* lists, association lists:              Pair and list jargon.
                                                              (line 135)
* lists, the empty list:                 Pair and list jargon.
                                                              (line  74)
* lists, list procedure:                 Pair and list procedures.
                                                              (line 322)
* lists, list type:                      Pair and list jargon.
                                                              (line 104)
* lists, proper lists:                   Pair and list jargon.
                                                              (line 112)
* lists, termination of lists:           Pair and list jargon.
                                                              (line 105)
* pairs, dotted pairs:                   Pair and list jargon.
                                                              (line 127)
* pairs, improper lists:                 Pair and list jargon.
                                                              (line 120)
* pairs, pair type:                      Pair and list jargon.
                                                              (line  83)
* proper list:                           Pair and list jargon.
                                                              (line 112)
* Scheme standards:                      Introduction.        (line  39)

Type Index
**********

* Menu:

* empty list:                            Pair and list jargon.
                                                              (line  74)
* empty list, predicate, null?:          Pair and list procedures.
                                                              (line 265)
* list:                                  Pair and list jargon.
                                                              (line 104)
* list, constructors, list:              Pair and list procedures.
                                                              (line 322)
* list, constructors, list-copy:         Pair and list procedures.
                                                              (line 500)
* list, constructors, make-list:         Pair and list procedures.
                                                              (line 301)
* list, mutator, list-set!:              Pair and list procedures.
                                                              (line 404)
* list, predicates, list?:               Pair and list procedures.
                                                              (line 280)
* list, predicates, proper-list?:        Pair and list procedures.
                                                              (line 280)
* list, selectors, assoc:                Pair and list procedures.
                                                              (line 450)
* list, selectors, assq:                 Pair and list procedures.
                                                              (line 450)
* list, selectors, assv:                 Pair and list procedures.
                                                              (line 450)
* list, selectors, list-ref:             Pair and list procedures.
                                                              (line 395)
* list, selectors, list-tail:            Pair and list procedures.
                                                              (line 377)
* list, selectors, member:               Pair and list procedures.
                                                              (line 414)
* list, selectors, memq:                 Pair and list procedures.
                                                              (line 414)
* list, selectors, memv:                 Pair and list procedures.
                                                              (line 414)
* pair:                                  Pair and list jargon.
                                                              (line  83)
* pair, constructor, cons:               Pair and list procedures.
                                                              (line 151)
* pair, mutators, set-car!:              Pair and list procedures.
                                                              (line 193)
* pair, mutators, set-cdr!:              Pair and list procedures.
                                                              (line 204)
* pair, predicate, pair?:                Pair and list procedures.
                                                              (line 141)
* pair, selectors, car:                  Pair and list procedures.
                                                              (line 169)
* pair, selectors, cdr:                  Pair and list procedures.
                                                              (line 181)
* pair, selectors, scheme/cxr:           Pair and list procedures.
                                                              (line 215)

Index of procedures and syntactic forms
***************************************

* Menu:

* append:                                Pair and list procedures.
                                                              (line 343)
* assoc:                                 Pair and list procedures.
                                                              (line 452)
* assq:                                  Pair and list procedures.
                                                              (line 450)
* assv:                                  Pair and list procedures.
                                                              (line 451)
* caaaar:                                Pair and list procedures.
                                                              (line 227)
* caaadr:                                Pair and list procedures.
                                                              (line 228)
* caaar:                                 Pair and list procedures.
                                                              (line 219)
* caadar:                                Pair and list procedures.
                                                              (line 229)
* caaddr:                                Pair and list procedures.
                                                              (line 230)
* caadr:                                 Pair and list procedures.
                                                              (line 220)
* caar:                                  Pair and list procedures.
                                                              (line 215)
* cadaar:                                Pair and list procedures.
                                                              (line 231)
* cadadr:                                Pair and list procedures.
                                                              (line 232)
* cadar:                                 Pair and list procedures.
                                                              (line 221)
* caddar:                                Pair and list procedures.
                                                              (line 233)
* cadddr:                                Pair and list procedures.
                                                              (line 234)
* caddr:                                 Pair and list procedures.
                                                              (line 222)
* cadr:                                  Pair and list procedures.
                                                              (line 216)
* car:                                   Pair and list procedures.
                                                              (line 169)
* cdaaar:                                Pair and list procedures.
                                                              (line 235)
* cdaadr:                                Pair and list procedures.
                                                              (line 236)
* cdaar:                                 Pair and list procedures.
                                                              (line 223)
* cdadar:                                Pair and list procedures.
                                                              (line 237)
* cdaddr:                                Pair and list procedures.
                                                              (line 238)
* cdadr:                                 Pair and list procedures.
                                                              (line 224)
* cdar:                                  Pair and list procedures.
                                                              (line 217)
* cddaar:                                Pair and list procedures.
                                                              (line 239)
* cddadr:                                Pair and list procedures.
                                                              (line 240)
* cddar:                                 Pair and list procedures.
                                                              (line 225)
* cdddar:                                Pair and list procedures.
                                                              (line 241)
* cddddr:                                Pair and list procedures.
                                                              (line 242)
* cdddr:                                 Pair and list procedures.
                                                              (line 226)
* cddr:                                  Pair and list procedures.
                                                              (line 218)
* cdr:                                   Pair and list procedures.
                                                              (line 181)
* cons:                                  Pair and list procedures.
                                                              (line 151)
* length:                                Pair and list procedures.
                                                              (line 333)
* list:                                  Pair and list procedures.
                                                              (line 322)
* list-copy:                             Pair and list procedures.
                                                              (line 500)
* list-ref:                              Pair and list procedures.
                                                              (line 395)
* list-set!:                             Pair and list procedures.
                                                              (line 404)
* list-tail:                             Pair and list procedures.
                                                              (line 377)
* list?:                                 Pair and list procedures.
                                                              (line 280)
* make-list:                             Pair and list procedures.
                                                              (line 301)
* member:                                Pair and list procedures.
                                                              (line 416)
* memq:                                  Pair and list procedures.
                                                              (line 414)
* memv:                                  Pair and list procedures.
                                                              (line 415)
* null?:                                 Pair and list procedures.
                                                              (line 265)
* pair?:                                 Pair and list procedures.
                                                              (line 141)
* proper-list?:                          Pair and list procedures.
                                                              (line 281)
* reverse:                               Pair and list procedures.
                                                              (line 366)
* set-car!:                              Pair and list procedures.
                                                              (line 193)
* set-cdr!:                              Pair and list procedures.
                                                              (line 204)

