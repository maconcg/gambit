(define-record-type achar
  (adorn-char char kind mesg peer)
  adorned-char?
  (char get-char set-char!)
  (kind get-kind set-kind!)
  (mesg get-mesg set-mesg!)
  (peer get-peer set-peer!))

(define (char-in char list-of-chars)
  (member char list-of-chars char=?))

(define (fresh-kind c)
  (cond ((char=? c #\.)                            'dot)
        ((char=? c #\|)                            'identifier)
        ((char=? c #\\)                            'infix)
        ((char=? c #\;)                            'line-comment)
        ((char=? c #\()                            'list)
        ((char=? c #\")                            'string)
        ((char-in c '( #\' #\` #\, ))              'abbrev)
        ((char-in c '( #\{ #\} ))                  'brace)
        ((char-in c '( #\[ #\] ))                  'bracket)
        ((char-in c '( #\newline #\space #\tab ))  'whitespace)
        (else                                      'tbd)))

(define (fresh-message c)
  (cond ((char=? c #\|)  'identifier)
        ((char=? c #\,)  'abbrev-if-@)
        ((char=? c #\#)  'octothorpe-begin)
        ((char=? c #\")  'string)
        ((char=? c #\;)  'line-comment)
        (else            #f)))

(define (refresh! ac)
  (let ((c (get-char ac)))
    (set-kind! ac (fresh-kind c))
    (set-mesg! ac (fresh-message c))))

(define (invalidate! ac)
  (set-kind! ac 'invalid)
  (set-mesg! ac 'invalid))
;-----------------------------------------------------------------------------;
(define (digit2?  c) (char-in c '( #\0 #\1 )))
(define (digit8?  c) (char-in c '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 )))
(define (digit10? c) (char-in c '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 )))
(define (digit16? c) (char-in c '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
                                   #\a #\b #\c #\d #\e #\f
                                   #\A #\B #\C #\D #\E #\F )))
;-----------------------------------------------------------------------------;
(define (opening-delimiter? c)
  (char-in c '( #\newline #\space #\tab #\| #\" #\; #\( )))

(define (closing-delimiter? c)
  (char=? c #\)))

(define (delimiter? c)
  (or (opening-delimiter? c) (closing-delimiter? c)))

(define (exactness-char? c)
  (char-in c '( #\e #\i )))

(define (exponent-or-precision-char? c)
  (char-in c '( #\e #\s #\f #\d #\l #\E #\S #\F #\D #\L )))

(define (radix-char? c)
  (char-in c '( #\x #\d #\o #\b )))
;-----------------------------------------------------------------------------;
(define (preceding-tbd ac-list)
  (list->string (let loop ((new '()) (old ac-list))
                  (if (null? old)
                      new
                      (let ((first (car old)))
                        (if (eq? (get-kind first) 'tbd)
                            (loop (cons (get-char first) new)
                                  (cdr old))
                            new))))))

(define (tbd-in token ac-list)
  (member
   (preceding-tbd ac-list)
   (cadr (assq token
               '((char ("#\\null" "#\\alarm" "#\\backspace" "#\\tab" "#\\space"
                        "#\\newline" "#\\return" "#\\delete" "#\\escape"
                        "#\\page" "#\\vtab" "#\\esc" "#\\linefeed" "#\\nul"))
                 (directive ("#!fold-case" "#!no-fold-case"))
                 (false ("#f" "#false"))
                 (fvector ("#f32" "#f64"))
                 (runtime-syntax ("and" "begin" "c-declare" "c-define"
                                  "c-define-type" "c-initialize" "c-lambda"
                                  "case" "case-lambda" "cond" "cond-expand"
                                  "declare" "define" "define-library"
                                  "define-macro" "define-record-type"
                                  "define-structure" "define-syntax"
                                  "define-type" "define-type-of-thread"
                                  "define-values" "delay" "delay-force" "do"
                                  "future" "guard" "if" "import" "include"
                                  "include-ci" "lambda" "let" "let*"
                                  "let*-values" "let-values" "letrec" "letrec*"
                                  "letrec*-values" "letrec-values" "namespace"
                                  "or" "parameterize" "quasiquote" "quote"
                                  "r7rs-guard" "receive" "set!" "syntax-error"
                                  "syntax-rules" "this-source-file" "unless"
                                  "when"))
                 (sharp ("#!eof" "#!key" "#!optional" "#!rest" "#!void"))
                 (svector ("#s8" "#s16" "#s32" "#s64"))
                 (true ("#t" "#true"))
                 (uvector ("#u8" "#u16" "#u32" "#u64")))))
   string=?))

(define (vector-string->kind s)
  (string->symbol (string-append (string-copy s 1) "vector")))

(define (peer! nac peer-char ac-list)
  (let ((empty? #t)
        (append-empty (lambda (kind)
                        (string->symbol (string-append (symbol->string kind)
                                                       "-empty"))))
        (kind->length (lambda (kind)
                        (cond ((eq? kind 'vector) 1)
                              ((memq kind '(u8vector s8vector)) 3)
                              ((memq kind '(u16vector u32vector u64vector
                                            s16vector s32vector s64vector
                                            f32vector f64vector)) 4)
                              (else 0)))))
    (let loop ((rest ac-list))
      (if (null? rest)
          (invalidate! nac)
          (let ((ac (car rest)))
            (let ((ac-kind (get-kind ac))
                  (ac-mesg (get-mesg ac)))
              (if (and (number? ac-mesg)
                       (not (get-peer ac))
                       (char=? (get-char ac) peer-char))
                  (begin (if empty?
                             (let ((ac-kind-empty (append-empty ac-kind)))
                               (begin (revise-kinds! rest
                                                     ac-kind-empty
                                                     ac-kind
                                                     (kind->length ac-kind))
                                      (set-kind! nac ac-kind-empty)))
                             (set-kind! nac ac-kind))
                         (set-peer! ac (get-mesg nac))
                         (set-peer! nac ac-mesg))
                  (begin (unless (eq? ac-kind 'whitespace) (set! empty? #f))
                         (loop (cdr rest))))))))))

(define (nested-comment-peer! nac pac ac-list)
  (let loop ((rest ac-list))
    (if (null? rest)
        #f
        (let ((dr (cdr rest)))
          (if (null? dr)
              #f
              (let ((acA (car rest))
                    (acB (car dr)))
                (if (or (not (eq? (get-kind acA) 'nested-comment))
                        (not (eq? (get-kind acB) 'nested-comment)))
                    #f
                    (let ((Ac (get-char acA))
                          (Bc (get-char acB)))
                      (let ((Ap (get-peer acA)))
                        (cond ((and (char=? Ac #\|) (char=? Bc #\#))
                               (set-peer! pac Ap)
                               (set-peer! nac (- (get-mesg nac) 1))
                               (set-mesg! pac ((if (char=? (get-char nac) #\|)
                                                   +
                                                   -) (get-mesg acB) 1))
                               (let ((ddr (cdr dr)))
                                 (when (or (null? ddr)
                                           (not (eq? (get-kind (car ddr))
                                                     'nested-comment)))
                                   (set-mesg! acB Ap))))
                              ((and (char=? Ac #\#) (char=? Bc #\|))
                               (set-peer! pac Ap)
                               (set-peer! nac (- (get-mesg nac) 1))
                               (set-mesg! pac ((if (char=? (get-char nac) #\|)
                                                   +
                                                   -) (get-mesg acB) 1)))
                              (else (loop (cdr rest)))))))))))))

(define (revise-kinds! ac-list new-kind . optionals)
  (let ((old-kind (if (null? optionals)
                      'tbd
                      (car optionals)))
        (limit (if (or (null? optionals) (null? (cdr optionals)))
                   #f
                   (cadr optionals))))
    (let loop ((rest ac-list) (count 0))
      (unless (or (null? rest) (and limit (> count limit)))
        (let ((ac (car rest)))
          (when (eq? (get-kind ac) old-kind)
            (set-kind! ac new-kind)
            (loop (cdr rest) (+ count 1))))))))

(define (adorn-list char-list)
  (let loop ((adorned '()) (unadorned char-list) (adorned-length 0))
    (if (null? unadorned)
        (reverse (cdr (cons (adorn! #\space adorned adorned-length) adorned)))
        (loop (cons (adorn! (car unadorned) adorned adorned-length) adorned)
              (cdr unadorned)
              (+ adorned-length 1)))))

(define (adorn! next-unadorned-char rest adorned-length)
  (let ((nac (adorn-char next-unadorned-char 'tbd #f #f)))
    (if (null? rest)
        (begin (refresh! nac)
               (if (char=? (get-char nac) #\()
                   (set-mesg! nac adorned-length)
                   (when (char=? (get-char nac) #\))
                     (invalidate! nac))))
        (let ((nc (get-char nac))
              (pac (car rest)))
          (let ((pc (get-char pac))
                (pk (get-kind pac))
                (pm (get-mesg pac)))
            (when (and (opening-delimiter? nc) (eq? pm 'invalid))
              (refresh! nac)
              (set-mesg! nac adorned-length))
            (cond ((eq? pm 'invalid)
                   (if (opening-delimiter? nc)
                       (set-mesg! nac adorned-length)
                       (invalidate! nac)))
                  ((not (symbol? pm))
                   (refresh! nac)
                   (let ((maybe-revise!
                          (lambda ()
                            (cond ((and (char=? #\: pc)
                                        (not (delimiter? (cadr rest))))
                                   (revise-kinds! rest 'keyword))
                                  ((tbd-in 'runtime-syntax rest)
                                   (revise-kinds! rest 'runtime-syntax))
                                  (else (revise-kinds! rest 'default))))))
                     (cond ((char=? nc #\()
                            (maybe-revise!)
                            (set-mesg! nac adorned-length))
                           ((char=? nc #\))
                            (maybe-revise!)
                            (set-mesg! nac adorned-length)
                            (peer! nac #\( rest))
                           ((delimiter? nc)
                            (maybe-revise!)))))
                  ((eq? pm 'identifier)
                   (when (char=? pc #\|)
                     (let ((dr (cdr rest)))
                       (when (or (null? dr)
                                 (not (eq? (get-kind (car dr)) 'identifier)))
                         (set-mesg! pac (- adorned-length 1)))))
                   (set-kind! nac 'identifier)
                   (if (and (char=? nc #\|) (not (char=? pc #\\)))
                       (begin (set-mesg! nac adorned-length)
                              (peer! nac #\| rest))
                       (set-mesg! nac 'identifier)))
                  ((eq? pm 'line-comment)
                   (if (char=? nc #\newline)
                       (refresh! nac)
                       (begin (set-kind! nac 'line-comment)
                              (set-mesg! nac 'line-comment))))
                  ((eq? pm 'nested-comment)
                   (set-kind! nac 'nested-comment)
                   (cond ((and (char=? nc #\|) (char=? pc #\#))
                          (unless (get-peer pac)
                            (set-mesg! nac adorned-length)
                            (nested-comment-peer! nac pac (cdr rest)))
                          (set-mesg! nac 'nested-comment))
                         ((and (char=? nc #\#)
                               (char=? pc #\|)
                               (not (get-peer pac)))
                          (set-mesg! nac adorned-length)
                          (nested-comment-peer! nac pac (cdr rest))
                          (let ((pm (get-mesg pac)))
                            (if (and (number? pm) (positive? pm))
                                (set-mesg! nac 'nested-comment)
                                (begin (set-mesg! nac adorned-length)
                                       (peer! nac #\# (cdr rest))))))
                         (else (set-mesg! nac 'nested-comment))))
                  ((eq? pm 'string)
                   (when (char=? pc #\")
                     (let ((dr (cdr rest)))
                       (when (or (null? dr)
                                 (not (eq? (get-kind (car dr)) 'string)))
                         (set-mesg! pac (- adorned-length 1)))))
                   (set-kind! nac 'string)
                   (if (and (char=? nc #\") (not (char=? pc #\\)))
                       (begin (set-mesg! nac adorned-length)
                              (peer! nac #\" rest))
                       (set-mesg! nac 'string)))
                  ((eq? pm 'char-begin)
                   (set-mesg! nac 'char-first))
                  ((eq? pm 'char-first)
                   (if (closing-delimiter? nc)
                       (begin (revise-kinds! rest 'char)
                              (set-mesg! nac adorned-length)
                              (peer! nac #\( rest))
                       (if (delimiter? nc)
                           (begin (revise-kinds! rest 'char)
                                  (refresh! nac))
                           (set-mesg! nac 'named-char))))
                  ((eq? pm 'named-char)
                   (if (delimiter? nc)
                       (begin (refresh! nac)
                              (revise-kinds! rest (if (tbd-in 'char rest)
                                                      'char
                                                      'invalid))
                              (when (closing-delimiter? nc)
                                (set-mesg! nac adorned-length)
                                (peer! nac #\( rest)))
                       (set-mesg! nac 'named-char)))
                  ((eq? pm 'directive-or-sharp)
                   (if (delimiter? nc)
                       (begin (refresh! nac)
                              (if (tbd-in 'directive rest)
                                  (revise-kinds! rest 'directive)
                                  (if (tbd-in 'sharp rest)
                                      (revise-kinds! rest 'sharp)
                                      (revise-kinds! rest 'invalid))))
                       (set-mesg! nac 'directive-or-sharp)))
                  ((memq pm '(svector uvector))
                   (if (delimiter? nc)
                       (if (char=? nc #\()
                           (let ((tbd (tbd-in pm rest)))
                             (if tbd
                                 (let ((nk (vector-string->kind (car tbd))))
                                   (begin (set-kind! nac nk)
                                          (set-mesg! nac adorned-length)
                                          (revise-kinds! rest nk)))
                                 (begin (refresh! nac)
                                        (revise-kinds! rest 'invalid))))
                           (begin (refresh! nac)
                                  (revise-kinds! rest 'invalid)))
                       (set-mesg! nac pm)))
                  ((eq? pm 'false-or-fvector)
                   (if (delimiter? nc)
                       (if (char=? nc #\()
                           (let ((tbd (tbd-in 'fvector rest)))
                             (if tbd
                                 (let ((nk (vector-string->kind (car tbd))))
                                   (begin (set-kind! nac nk)
                                          (set-mesg! nac adorned-length)
                                          (revise-kinds! rest nk)))
                                 (begin (refresh! nac)
                                        (revise-kinds! rest 'invalid))))
                           (begin (refresh! nac)
                                  (revise-kinds! rest (if (tbd-in 'false rest)
                                                          'boolean
                                                          'invalid))))
                       (set-mesg! nac 'false-or-fvector)))
                  ((eq? pm 'true)
                   (if (delimiter? nc)
                       (begin (revise-kinds! rest (if (tbd-in 'true rest)
                                                      'boolean
                                                      'invalid))
                              (refresh! nac))
                       (set-mesg! nac 'true)))
                  ((eq? pm 'label-or-reference)
                   (cond ((digit10? nc)
                          (set-mesg! nac 'label-or-reference))
                         ((delimiter? nc)
                          (set-kind! nac 'serial-reference)
                          (revise-kinds! rest 'serial-reference))
                         ((char=? nc #\=)
                          (set-kind! nac 'datum-label)
                          (revise-kinds! rest 'datum-label))
                         ((char=? nc #\#)
                          (set-kind! nac 'datum-reference)
                          (revise-kinds! rest 'datum-reference))
                         (else (invalidate! nac)
                               (revise-kinds! rest 'invalid))))
                  ((eq? pm 'octothorpe-begin)
                   (cond ((char=? nc #\&)
                          (set-kind! nac (revise-kinds! rest 'box)))
                         ((char=? nc #\\)
                          (set-mesg! nac 'char-begin))
                         ((char=? nc #\|)
                          (set-kind! pac 'nested-comment)
                          (set-mesg! pac 1)
                          (set-kind! nac 'nested-comment)
                          (set-peer! nac (- adorned-length 1))
                          (set-mesg! nac 'nested-comment))
                         ((char=? nc #\f)
                          (set-mesg! nac 'false-or-fvector))
                         ((char=? nc #\s)
                          (set-mesg! nac 'svector))
                         ((char=? nc #\t)
                          (set-mesg! nac 'true))
                         ((char=? nc #\u)
                          (set-mesg! nac 'uvector))
                         ((digit10? nc)
                          (set-mesg! nac 'label-or-reference))
                         ((char=? nc #\!)
                          (set-mesg! nac 'directive-or-sharp))
                         ((exactness-char? nc)
                          (set-mesg! nac 'radix-or-digit10))
                         ((char=? nc #\()
                          (set-kind! nac 'vector)
                          (set-mesg! nac adorned-length)
                          (revise-kinds! rest 'vector))
                         ((radix-char? nc)
                          (set-mesg! nac ((cond ((char=? nc #\x)
                                                 'exactness-or-digit16)
                                                ((char=? nc #\d)
                                                 'exactness-or-digit10)
                                                ((char=? nc #\o)
                                                 'exactness-or-digit8)
                                                ((char=? nc #\b)
                                                 'exactness-or-digit2)
                                                (else 'invalid)))))
                         ((char=? nc #\;)
                          (set-kind! nac 'datum-comment)
                          (set-mesg! 'datum-comment))
                         (else
                          (invalidate! nac))))
                  (else (refresh! nac))))))
    nac))
