(define-record-type adorned-char
  (make-adorned-char char kind message)
  adorned-char?
  (char get-char set-char!)
  (kind get-kind set-kind!)
  (message get-message set-message!))

(define (adorn-char char)
  (make-adorned-char char 'tbd #f))

(define (char-in char list-of-chars)
  (member char list-of-chars char=?))

(define (fresh-kind c)
  (cond ((char=? c #\.)                            'dot)
        ((char=? c #\|)                            'identifier)
        ((char=? c #\\)                            'infix)
        ((char=? c #\;)                            'line-comment)
        ((char=? c #\")                            'string)
        ((char-in c '( #\' #\` #\, ))              'abbrev)
        ((char-in c '( #\{ #\} ))                  'brace)
        ((char-in c '( #\[ #\] ))                  'bracket)
        ((char-in c '( #\( #\) ))                  'paren)
        ((char-in c '( #\newline #\space #\tab ))  'whitespace)
        ((digit10? c)                              'number10)
        (else                                      'tbd)))

(define (fresh-message c)
  (cond ((char=? c #\|) 'identifier)
        ((char=? c #\,) 'abbrev-if-@)
        ((char=? c #\#) 'special-begin)
        ((char=? c #\") 'string)
        ((char=? c #\;) 'line-comment)
        (else           #f)))

(define (refresh! ac)
  (let ((c (get-char ac)))
    (set-kind! ac (fresh-kind c))
    (set-message! ac (fresh-message c))))

(define (invalidate! ac)
  (set-kind! ac 'invalid)
  (set-message! ac 'invalid))
;-----------------------------------------------------------------------------;
(define (digit2?  c) (char-in c '( #\0 #\1 )))
(define (digit8?  c) (char-in c '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 )))
(define (digit10? c) (char-in c '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 )))
(define (digit16? c) (char-in c '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
                                 #\a #\b #\c #\d #\e #\f
                                 #\A #\B #\C #\D #\E #\F )))
;-----------------------------------------------------------------------------;
(define (delimiter? c)
  (char-in c '( #\| #\( #\) #\" #\; #\newline #\space #\tab )))

(define (exactness-char? c)
  (char-in c '( #\e #\i )))

(define (exponent-or-precision-char? c)
  (char-in c '( #\e #\s #\f #\d #\l #\E #\S #\F #\D #\L )))

(define (radix-char? c)
  (char-in c '( #\x #\d #\o #\b )))
;-----------------------------------------------------------------------------;
(define (preceding-tbd ac-list)
  (list->string (let loop ((new '()) (old ac-list))
                  (if (null? old)
                      new
                      (let ((first (car old)))
                        (if (eq? (get-kind first) 'tbd)
                            (loop (cons (get-char first) new)
                                  (cdr old))
                            new))))))

(define token-strings
  (list (cons 'char '("#\\alarm" "#\\backspace" "#\\delete" "#\\esc"
                      "#\\escape" "#\\linefeed" "#\\newline" "#\\nul" "#\\null"
                      "#\\page" "#\\return" "#\\space" "#\\tab" "#\\vtab"))
        (cons 'false '("#f" "#false"))
        (cons 'fvector '("#f32" "#f64"))
        (cons 'svector '("#s8" "#s16" "#s32" "#s64"))
        (cons 'true '("#t" "#true"))
        (cons 'uvector '("#u8" "#u16" "#u32" "#u64"))))

(define (tbd-is? token ac-list)
  (member (preceding-tbd ac-list)
          (cdr (assq token token-strings))
          string=?))

(define (revise-kinds! ac-list new-kind . optional-old-kind)
  (call-with-current-continuation
   (lambda (done)
     (let ((old-kind (if (null? optional-old-kind)
                         'tbd
                         (car optional-old-kind))))
       (let loop ((rest ac-list))
         (if (null? rest)
             #t
             (let ((ac (car rest)))
               (if (eq? (get-kind ac) old-kind)
                   (begin (set-kind! ac new-kind)
                          (loop (cdr rest)))
                   (done new-kind)))))))))

(define (maybe-revise-list-or-vector! ac-list)
  (let ((eligible-kinds '(paren fvector svector uvector vector))
        (empty? #t))
    (let loop ((rest ac-list))
      (if (null? rest)
          #f
          (let* ((ac (car rest))
                 (kind (get-kind ac)))
            (guard (s ((eq? s 'revise)
                       (let ((new-kind (string->symbol (string-append
                                                        (symbol->string kind)
                                                        "-empty"))))
                         (revise-kinds! rest new-kind kind)
                         ac))
                      ((eq? s 'abort) ac))
              (cond ((memq kind eligible-kinds) (if empty?
                                                    (raise 'revise)
                                                    (raise 'abort)))
                    ((eq? kind 'whitespace) (loop (cdr rest)))
                    (else (when empty? (set! empty? #f))
                          (loop (cdr rest))))))))))

(define (adorn-list char-list)
  (let loop ((adorned '()) (unadorned char-list))
    (if (null? unadorned)
        (reverse adorned)
        (loop (cons (adorn! (car unadorned) adorned) adorned)
              (cdr unadorned)))))

(define (adorn! next-unadorned-char rest)
  (let ((nac (adorn-char next-unadorned-char)))
    (if (null? rest)
        (refresh! nac)
        (let ((nc (get-char nac))
              (prev (car rest)))
          (let ((pc (get-char prev))
                (pk (get-kind prev))
                (pm (get-message prev)))
            (cond ((and (eq? pm 'invalid) (not (delimiter? nc)))
                   (invalidate! nac))
                  ((eq? pm 'identifier)
                   (cond ((and (char=? nc #\|) (not (char=? pc #\\)))
                          (set-message! nac #f))
                         (else (set-message! nac 'identifier)))
                   (set-kind! nac 'identifier))
                  ((eq? pm 'line-comment)
                   (cond ((char=? nc #\newline) (refresh! nac))
                         (else (set-kind! nac 'line-comment)
                               (set-message! nac 'line-comment))))
                  ((eq? pm 'string)
                   (cond ((and (char=? nc #\") (not (char=? pc #\\)))
                          (set-message! nac #f))
                         (else (set-message! nac 'string)))
                   (set-kind! nac 'string))
                  ((eq? pm 'char-begin)
                   (set-message! nac 'char-first))
                  ((eq? pm 'char-first)
                   (cond ((delimiter? nc)
                          (revise-kinds! rest 'char)
                          (refresh! nac))
                         (else (set-message! nac 'named-char))))
                  ((eq? pm 'named-char)
                   (cond ((delimiter? nc)
                          (revise-kinds! rest (if (tbd-is? 'char rest)
                                                  'char
                                                  'invalid))
                          (refresh! nac))
                         (else (set-message! nac 'named-char))))
                  ((eq? pm 'false-or-fvector)
                   (cond ((delimiter? nc)
                          (cond ((tbd-is? 'false rest)
                                 (revise-kinds! rest 'boolean)
                                 (refresh! nac))
                                ((and (tbd-is? 'fvector rest) (char=? nc #\())
                                 (set-kind! nac (revise-kinds! rest 'fvector)))
                                (else (revise-kinds! rest 'invalid))))
                         (else (set-message! nac 'false-or-fvector))))
                  ((eq? pm 'special-begin)
                   (cond ((char=? nc #\&)
                          (set-kind! nac (revise-kinds! rest 'box)))
                         ((char=? nc #\\)
                          (set-message! nac 'char-begin))
                         ((char=? nc #\|)
                          (set-kind! nac 'nested-comment)
                          (set-message! nac 'nested-comment))
                         ((char=? nc #\f)
                          (set-message! nac 'false-or-fvector))
                         ((char=? nc #\s)
                          (set-message! nac 'svector))
                         ((char=? nc #\t)
                          (set-message! nac 'true))
                         ((char=? nc #\u)
                          (set-message! nac 'uvector))
                         ((digit10? nc)
                          (set-message! nac 'label-or-reference-or-serial))
                         ((char=? nc #\!)
                          (set-message! nac 'directive-or-sharp-object))
                         ((exactness-char? nc)
                          (set-message! nac 'radix-or-digit10))
                         ((char=? nc #\()
                          (set-message! nac 'vector-begin))
                         ((radix-char? nc)
                          (set-message! nac ((cond ((char=? nc #\x)
                                                    'exactness-or-digit16)
                                                   ((char=? nc #\d)
                                                    'exactness-or-digit10)
                                                   ((char=? nc #\o)
                                                    'exactness-or-digit8)
                                                   ((char=? nc #\b)
                                                    'exactness-or-digit2)
                                                   (else 'invalid)))))
                         ((char=? nc #\;)
                          (set-kind! nac 'datum-comment)
                          (set-message! 'datum-comment))
                         (else
                          (invalidate! nac))))
                  ((memq pm '(svector uvector))
                   (cond ((delimiter? nc)
                          (cond ((and (tbd-is? pm rest) (char=? nc #\())
                                 (revise-kinds! rest pm)
                                 (set-kind! nac pm))
                                (else (revise-kinds! rest 'invalid))))
                         (else (set-message! nac pm))))
                  ((eq? pm 'true)
                   (cond ((delimiter? nc)
                          (revise-kinds! rest (if (tbd-is? 'true rest)
                                                  'boolean
                                                  'invalid))
                          (refresh! nac))
                         (else (set-message! nac 'true))))
                  ((and (not pm) (delimiter? nc))
                   (revise-kinds! rest 'default)
                   (refresh! nac)
                   (when (char=? nc #\))
                     (let ((beginning-ac (maybe-revise-list-or-vector! rest)))
                       (when (adorned-char? beginning-ac)
                         (let ((beginning-c (get-char beginning-ac))
                               (beginning-kind (get-kind beginning-ac)))
                           (when (char=? beginning-c #\()
                             (set-kind! nac beginning-kind)))))))
                  (else (refresh! nac))))))
    nac))
