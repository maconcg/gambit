(define-record-type adorned-char
  (make-adorned-char char kind message)
  adorned-char?
  (char get-char set-char!)
  (kind get-kind set-kind!)
  (message get-message set-message!))

(define (adorn-char char)
  (make-adorned-char char 'tbd #f))

(define (char-in list-of-chars char)
  (member char list-of-chars char=?))

(define (fresh-kind char)
  (cond ((char-in '( #\' #\` #\, ) char)              'abbrev)
        ((char=? #\\ char)                            'infix)
        ((digit10? char)                              'number10)
        ((char=? #\| char)                            'identifier)
        ((char-in '( #\{ #\} ) char)                  'brace)
        ((char-in '( #\[ #\] ) char)                  'bracket)
        ((char=? #\. char)                            'dot)
        ((char-in '( #\( #\) ) char)                  'paren)
        ((char=? #\" char)                            'string)
        ((char=? #\; char)                            'line-comment)
        ((char-in '( #\newline #\space #\tab ) char)  'whitespace)
        (else                                         'tbd)))

(define (fresh-message char)
  (cond ((char=?  #\|  char) 'identifier)
        ((char=?  #\,  char) 'abbrev-if-@)
        ((char=?  #\#  char) 'special-begin)
        ((char=?  #\"  char) 'string)
        ((char=?  #\;  char) 'line-comment)
        (else                #f)))

(define (refresh! ac)
  (let ((char (get-char ac)))
    (set-kind! ac (fresh-kind char))
    (set-message! ac (fresh-message char))))

(define (invalidate! ac)
  (set-kind! ac 'invalid)
  (set-message! ac 'invalid))
;-----------------------------------------------------------------------------;
(define (digit2?  c) (char-in '( #\0 #\1 ) c))
(define (digit8?  c) (char-in '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 ) c))
(define (digit10? c) (char-in '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 ) c))
(define (digit16? c) (char-in '( #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
                                 #\a #\b #\c #\d #\e #\f
                                 #\A #\B #\C #\D #\E #\F ) c))
;-----------------------------------------------------------------------------;
(define (delimiter? c)
  (char-in '( #\| #\( #\) #\" #\; #\newline #\space #\tab ) c))

(define (exactness-char? c)
  (char-in '( #\e #\i ) c))

(define (exponent-or-precision-char? c)
  (char-in '( #\e #\s #\f #\d #\l
               #\E #\S #\F #\D #\L ) c))

(define (hvector-letter? c)
  (char-in '( #\f #\s #\u ) c))

(define named-chars
  (list "alarm" "backspace" "delete" "esc" "escape" "linefeed" "newline"
        "nul" "null" "page" "return" "space" "tab" "vtab"))

(define named-char-firsts
  (letrec ((dedup (lambda (new old)
                    (cond ((null? old) new)
                          ((member (car old) new char=?)
                           (dedup new (cdr old)))
                          (else (dedup (cons (car old) new) (cdr old)))))))
    (list-sort char<? (dedup '() (map car (map string->list named-chars))))))

(define (radix-char? c)
  (char-in '( #\x #\d #\o #\b ) c))
;-----------------------------------------------------------------------------;
(define (preceding-tbd ac-list)
  (list->string (let loop ((new '()) (old ac-list))
                  (if (null? old)
                      new
                      (let ((first (car old)))
                        (if (eq? 'tbd (get-kind first))
                            (loop (cons (get-char first) new)
                                  (cdr old))
                            new))))))

(define (tbd-is-char? ac-list)
  (member (preceding-tbd ac-list)
          (map (lambda (s) (string-append "#\\" s)) named-chars)
          string=?))

(define (tbd-is-false? ac-list)
  (or (string=? "#f" (preceding-tbd ac-list))
      (string=? "#false" (preceding-tbd ac-list))))

(define (tbd-is-fvector? ac-list)
  (or (string=? "#f32" (preceding-tbd ac-list))
      (string=? "#f64" (preceding-tbd ac-list))))

(define (tbd-is-true? ac-list)
  (or (string=? "#t" (preceding-tbd ac-list))
      (string=? "#true" (preceding-tbd ac-list))))

(define (revise-kinds! ac-list old-kind new-kind)
  (call/cc (lambda (done)
             (for-each (lambda (ac)
                         (let ((ac-kind (get-kind ac)))
                           (if (eq? old-kind ac-kind)
                               (set-kind! ac new-kind)
                               (done new-kind))))
                       ac-list))))

(define (maybe-revise-empty-list! ac-list)
  (call/cc (lambda (done)
             (for-each (lambda (ac)
                         (let ((ac-kind (get-kind ac))
                               (ac-message (get-message ac)))
                           (when (char=? #\( (get-char ac))
                             (set-kind! ac 'empty-list-begin)
                             (done #t))
                           (unless (eq? 'whitespace ac-kind)
                             (done #f))))
                       ac-list))))

(define (adorn-list char-list)
  (let loop ((adorned '()) (unadorned char-list))
    (if (null? unadorned)
        (reverse adorned)
        (loop (cons (adorn! (car unadorned) adorned) adorned)
              (cdr unadorned)))))

(define (adorn! next rest)
  (let ((next (adorn-char next)))
    (if (null? rest)
        (refresh! next)
        (let ((nc (get-char next))
              (prev (car rest)))
          (let ((pc (get-char prev))
                (pk (get-kind prev))
                (pm (get-message prev)))
            (cond ((and (eq? 'invalid pm) (not (delimiter? nc)))
                   (invalidate! next))
                  ((eq? 'identifier pm)
                   (cond ((and (char=? #\| nc) (not (char=? #\\ pc)))
                          (set-message! next #f))
                         (else (set-message! next 'identifier)))
                   (set-kind! next 'identifier))
                  ((eq? 'line-comment pm)
                   (cond ((char=? #\newline nc) (refresh! next))
                         (else (set-kind! next 'line-comment)
                               (set-message! next 'line-comment))))
                  ((eq? 'string pm)
                   (cond ((and (char=? #\" nc) (not (char=? #\\ pc)))
                          (set-message! next #f))
                         (else (set-message! next 'string)))
                   (set-kind! next 'string))
                  ((eq? 'char-begin pm)
                   (set-message! next 'char-first))
                  ((eq? 'char-first pm)
                   (cond ((delimiter? nc)
                          (revise-kinds! rest 'tbd 'char)
                          (refresh! next))
                         ((member pc named-char-firsts char=?)
                          (set-message! next 'named-char))
                         (else (invalidate! next))))
                  ((eq? 'named-char pm)
                   (cond ((delimiter? nc)
                          (revise-kinds! rest 'tbd (if (tbd-is-char? rest)
                                                       'char
                                                       'invalid))
                          (refresh! next))
                         (else (set-message! next 'named-char))))
                  ((eq? 'false-or-fvector pm)
                   (cond ((delimiter? nc)
                          (cond ((tbd-is-false? rest)
                                 (revise-kinds! rest 'tbd 'boolean)
                                 (refresh! next))
                                ((and (tbd-is-fvector? rest) (char=? #\( nc))
                                 (revise-kinds! rest 'tbd 'fvector)
                                 (set-kind! next 'fvector))
                                (else (revise-kinds! rest 'tbd 'invalid))))
                         (else (set-message! next 'false-or-fvector))))
                  ((eq? 'special-begin pm)
                   (cond ((char=? #\& nc)
                          (revise-kinds! rest 'tbd 'box)
                          (set-kind! next 'box))
                         ((char=? #\\ nc)
                          (set-message! next 'char-begin))
                         ((char=? #\| nc)
                          (set-kind! next 'nested-comment)
                          (set-message! next 'nested-comment))
                         ((char=? #\f nc)
                          (set-message! next 'false-or-fvector))
                         ((char=? #\s nc)
                          (set-message! next 'svector))
                         ((char=? #\t nc)
                          (set-message! next 'true))
                         ((char=? #\u nc)
                          (set-message! next 'uvector))
                         ((digit10? nc)
                          (set-message! next 'label-or-reference-or-serial))
                         ((char=? #\! nc)
                          (set-message! next 'directive-or-sharp-object))
                         ((exactness-char? nc)
                          (set-message! next 'radix-or-digit10))
                         ((char=? #\( nc)
                          (set-message! next 'vector-begin))
                         ((radix-char? nc)
                          (set-message! next ((cond ((char=? #\x nc)
                                                     'exactness-or-digit16)
                                                    ((char=? #\d nc)
                                                     'exactness-or-digit10)
                                                    ((char=? #\o nc)
                                                     'exactness-or-digit8)
                                                    ((char=? #\b nc)
                                                     'exactness-or-digit2)
                                                    (else 'invalid)))))
                         ((char=? #\; nc)
                          (set-kind! next 'datum-comment)
                          (set-message! 'datum-comment))
                         (else
                          (invalidate! next))))
                  ((eq? 'true pm)
                   (cond ((delimiter? nc)
                          (revise-kinds! rest 'tbd (if (tbd-is-true? rest)
                                                       'boolean
                                                       'invalid))
                          (refresh! next))
                         (else (set-message! next 'true))))
                  ((and (not pm) (delimiter? nc))                   
                   (revise-kinds! rest 'tbd 'default)
                   (refresh! next)
                   (when (char=? #\) nc)
                     (when (maybe-revise-empty-list! rest)
                       (set-kind! next 'empty-list-end))))
                  (else (refresh! next))))))
    next))
