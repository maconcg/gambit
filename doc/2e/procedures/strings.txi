@node String procedures
@chapter String procedures

@deftypefn @t{(scheme base)} @/ string? obj
Returns @code{#t} if @var{obj} is a string.

@lisp
(string? "")                     @result{} #t
(string? #\a)                    @result{} #f
(string? "a")                    @result{} #t
(string? string)                 @result{} #f
(string? '(#\c #\h #\a #\r #\s)) @result{} #f
(string? #(#\c #\h #\a #\r #\s)) @result{} #f
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ make-string k [char]
@c Should this document that Gambit defaults char to \x0?
Returns a newly allocated string of length @var{k}.  In the one-argument
form, the contents of the string are unspecified.  In the two-argument
form, each character is initialized to @var{char}.

If @var{k} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If @var{k} is a negative exact
integer, an exception that satisfies @code{range-exception?} is raised.

@lisp
@c (string=? "\x0;" (make-string 1)) @result{} #t
(make-string 0)                 @result{} ""
(string-length (make-string 4)) @result{} 4
(make-string 4 #\g)             @result{} "gggg"
(make-string 4 "g")             @exception{type}
(make-string -1)                @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} {} string char@dots{}
Returns a newly allocated string whose elements are its arguments.  The
order of the arguments is preserved.  Analogous to @code{list}.

@lisp
(string)                         @result{} ""
(string #\G #\a #\m #\b #\i #\t) @result{} "Gambit"
(string (string->list "Gambit")) @result{} "Gambit"
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-length [string]
Returns the number of characters in @var{string}.
@lisp
(string-length (make-string 5)) @result{} 5
(string-length "")              @result{} 0
(string-length "lambda")        @result{} 6
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-ref string k
Returns the character at index @var{k} of @var{string}.  If @var{k} is
not a valid index of @var{string}, an exception that satisfies
@code{range-exception?} is raised.

@lisp
(define s "off by one")

(string-ref "zero-origin indexing" 0)   @result{} #\z
(string-ref s (- (string-length s) 1))  @result{} #\e
(string-ref s (string-length s))        @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string=? [string@dots{}]
Returns @code{#t} if all the @var{string}s are the same length and
contain exactly the same characters in the same positions, otherwise
returns @code{#f}.

Gambit extends the @value{R7RS} description of @code{string=?} to accept
any number of arguments.

@lisp
(string=? "abc" (string #\a #\b #\c)) @result{} #t
(string=? "abcd" "Abcd")              @result{} #f
(string=?)                            @result{} #t
(string=? "a" "a" "a")                @result{} #t
(string=? "a" #\a)                    @exception{type}
@end lisp
@end deftypefn

@deftypefn  @t{(scheme base)} @/ string<? [string@dots{}]
@deftypefnx @t{(scheme base)} @/ string>? [string@dots{}]
@deftypefnx @t{(scheme base)} @/ string<=? [string@dots{}]
@deftypefnx @t{(scheme base)} @/ string>=? [string@dots{}]
These predicates return @code{#t} if their arguments are (respectively):
monotonically increasing, monotonically decreasing, monotonically
non-decreasing, or monotonically non-increasing.  They are transitive.

A pair of strings satisfies exactly one of @code{string<?},
@code{string=?}, and @code{string>?}.  They may satisfy @code{string<=?}
if and only if they do not satisfy @code{string>?}.  They may satisfy
@code{string>=?} if and only if they do not satisfy @code{string<?}.

Gambit extends the @value{R7RS} descriptions of these procedures to
accept any number of arguments.

@lisp
(string<=? "g" "g") @result{} #f
(string>=? "g" "g") @result{} #f
(string<?  "g" "g") @result{} #f
(string>?  "g" "g") @result{} #f

(string<? "G" "g")  @result{} #t
(string>? "G" "g")  @result{} #f

(string<? "gg" "g") @result{} #f
(string>? "gg" "g") @result{} #t
@end lisp
@end deftypefn

@deftypefn  @t{(scheme char)} @/ string-ci=? [string@dots{}]
@deftypefnx @t{(scheme char)} @/ string-ci<? [string@dots{}]
@deftypefnx @t{(scheme char)} @/ string-ci>? [string@dots{}]
@deftypefnx @t{(scheme char)} @/ string-ci<=? [string@dots{}]
@deftypefnx @t{(scheme char)} @/ string-ci>=? [string@dots{}]
Each of these predicates behaves as if @code{string-foldcase} were
applied to each of its arguments, and then that predicate's
non-@samp{-ci} counterpart were applied to those case-folded arguments.

@lisp
(string-ci=?  "G" "g")  @result{} #t
(string-ci<=? "G" "g")  @result{} #f

(string-ci<?  "G" "g")  @result{} #f
(string-ci>?  "G" "g")  @result{} #f

(string-ci<?  "gg" "g") @result{} #f
(string-ci>?  "gg" "g") @result{} #t
@end lisp
@end deftypefn

@deftypefn @t{(scheme char)} @/ string-upcase string
@deftypefnx @t{(scheme char)} @/ string-downcase string
@deftypefnx @t{(scheme char)} @/ string-foldcase string
These procedures apply the Unicode full string uppercasing, lowercasing,
and case-folding algorithms to their arguments and return the result.
In certain cases, the result differs in length from @var{string}.  Note
that language-sensitive mappings and foldings are not used.

@set Etoc @U{0388}@U{03C4}@U{03BF}@U{03C2}
@set etoc @U{03AD}@U{03C4}@U{03BF}@U{03C2}
@set etoo @U{03AD}@U{03C4}@U{03BF}@U{03C3}
@set ETOS @U{0388}@U{03A4}@U{039F}@U{03A3}
@set WeiB Wei@ss{}
@set weiB wei@ss{}
@lisp
(string-downcase "@value{WeiB}")  @result{} "@value{weiB}"
(string-foldcase "@value{WeiB}")  @result{} "weiss"
(string-upcase   "@value{WeiB}")  @result{} "WEISS"

(string-downcase "WEISS") @result{} "weiss"
(string-foldcase "WEISS") @result{} "weiss"

(string-downcase "@value{Etoc}")  @result{} "@value{etoc}"
(string-foldcase "@value{Etoc}")  @result{} "@value{etoo}"
(string-upcase   "@value{Etoc}")  @result{} "@value{ETOS}"

(string-downcase "@value{ETOS}")  @result{} "@value{etoo}"
(string-foldcase "@value{ETOS}")  @result{} "@value{etoo}"
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-append string@dots{}

Returns a newly allocated string whose characters are the concatenation
of the characters in the given @var{string}s.

@lisp
(string-append)                     @result{} ""
(string-append "")                  @result{} ""
(string-append "hello" "world")     @result{} "helloworld"
(string-append "hello" "" "world")  @result{} "helloworld"
(string-append "hello " " world")   @result{} "hello  world"
(string-append "hello" " " "world") @result{} "hello world"
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string->list string [start [end]]
Returns a newly allocated list of characters in @var{string}.  In the
one-argument form, the returned list comprises all characters of
@var{string}.  In the two-argument form, the returned list comprises
characters from index @var{start} (inclusive) through the end of
@var{string}.  In the three-argument form, the returned list comprises
characters from index @var{start} (inclusive) through index @var{end}
(exclusive).

Order is preserved.  @code{string->list} and @code{list->string} are
inverses so far as @code{equal?} is concerned.  If either @var{start} or
@var{end} is not a valid index of @var{string}, an exception that
satisfies @code{range-exception?} is raised.

@lisp
(string->list "scheme")     @result{} (#\s #\c #\h #\e #\m #\e)
(string->list "scheme" 1)   @result{} (#\c #\h #\e #\m #\e)
(string->list "scheme" 2 6) @result{} (#\h #\e #\m #\e)
(string->list "scheme" 6)   @result{} ()
(string->list "scheme" 6 6) @result{} ()
(string->list "scheme" 7)   @exception{range}
(string->list "scheme" 3 7) @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list->string list
Returns a newly allocated string formed from the elements in @var{list}.

Order is preserved.  @code{list->string} and @code{string->list} and are
inverses so far as @code{equal?} is concerned.  If any element of
@var{list} is not a character, an exception that satisfies @code{type?}
is raised.

@lisp
(list->string (list))                       @result{} ""
(list->string '(#\s #\c #\h #\e #\m #\e))   @result{} "scheme"
(list->string '(#\s #\c #\h #\e #\m #\e 2)) @exception{type}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-copy [start [end]]
Returns a newly allocated string whose value is a portion of
@var{string}.  In the one-argument form, the returned portion is all of
@var{string}.  In the two-argument form, the returned string is a copy
of @var{string} from index @var{start} (inclusive) through the end of
@var{string}.  In the three-argument form, the returned string is a copy
of @var{string} from index @var{start} (inclusive) to index @var{end}
(exclusive).

Order is preserved.  @code{string->list} and @code{list->string} and are
inverses so far as @code{equal?} is concerned.  If either @var{start} or
@var{end} is not a valid index of @var{string}, an exception that
satisfies @code{range-exception?} is raised.

@lisp
(define s "dwim")

(string-copy s)                     @result{} "dwim"
(string-copy s 1)                   @result{} "wim"
(string-copy s 1 1)                 @result{} ""
(string-copy s 0 (string-length s)) @result{} "dwim"
(eqv?     s (string-copy s))        @result{} #f
(string=? s (string-copy s))        @result{} #t
(string-copy s 6)                   @exception{range}
(string-copy s -1 3)                @exception{range}
(string-copy s 2 5)                 @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-copy! to at from [start [end]]
Mutates string @var{to} by copying a substring of @var{from} into
@var{to}, beginning with index @var{at} of @var{to}.  In the
three-argument form, all of @var{from} is copied.  In the four-argument
form, the value of @samp{(string-copy @slanted{from} @slanted{start})}
is copied.  In the five-argument form, the value of @samp{(string-copy
@slanted{from} @slanted{start} @slanted{end})} is copied.

If @var{at} is not a valid index of @var{to}, an exception that
satisfies @code{range-exception?} is raised.  If @samp{(- (string-length
@slanted{to}) @slanted{at})} is less than @samp{(- @slanted{end}
@slanted{start})}, an exception that satisfies @code{range-exception?}
is raised (in other words, the copied substring must not overflow beyond
the end of @var{to}).

@lisp
(define a "12345")
(define b (string-copy "abcde"))

(string-copy! b 1 a 0 2)
b @result{} "a12de"
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-fill! string char [start [end]]
Mutates @var{string} by overwriting some or all of its elements with
@var{char}.  In the two-argument form, each element is overwritten.  In
the three-argument form, the elements from index @var{start} (inclusive)
through the end of @var{string} are overwritten.  In the four-argument
form, the elements from index @var{start} (inclusive) to index @var{end}
(exclusive) are overwritten.

If either @var{start} or @var{end} is not a valid index of @var{string},
an exception that satisfies @code{range-exception?} is raised.

@lisp
(define a (string-copy "abcde"))
(define b (string-copy a))
(define c (string-copy b))

(string-fill! a #\0)
(string-fill! b #\0 3)
(string-fill! c #\0 3 4)
a @result{} "00000"
b @result{} "abc00"
c @result{} "abc0e"
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ string-set! string k char
Mutates @var{string} by storing @var{char} in element @var{k} of
@var{string}.

If @var{string} is not a mutable string, an exception that satisfies
@code{type-exception?} is raised.  If @var{k} is not a valid index of
@var{string}, an exception that satisfies @code{range-exception?} is
raised.

@lisp
(define (f) (make-string 3 #\*))
(define (g) "***")

(string-set! (f) 0 #\?) @slanted{;; legal, but useless}
(string-set! (g) 0 #\?) @slanted{;; r7rs says this is an error}
(string-set! (symbol->string 'immutable) 0 #\?) @exception{type}
(string-set! (f) 5 #\?)                         @exception{range}
@end lisp
@end deftypefn
