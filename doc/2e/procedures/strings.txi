@node String procedures
@chapter String procedures

@deftypefn scheme/base @/ string? obj
Returns @code{#t} if @var{obj} is a string.

@lisp
(string? @string{}) @value{true}
(string? @string{}) @value{true}
@end lisp

@lisp
(string? @char{a})                    @value{false}
(string? 'string)                @value{false}
(string? '(@char{c} @char{h} @char{a} @char{r} @char{s})) @value{false}
(string? #(@char{c} @char{h} @char{a} @char{r} @char{s})) @value{false}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ make-string k @opt{char}
Returns a newly allocated string of length @var{k}.  In the one-argument
form, each character is initialized to a default value.  In the
two-argument form, each character is initialized to @var{char}.

The default value used by the one-argument form may change in a future
version.  Programs that require a specific initialization value should
use the two-argument form.

If @var{k} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If @var{k} is a negative exact
integer, an exception that satisfies @code{range-exception?} is raised.

@lisp
(make-string 0)                 @ok{""}
(string-length (make-string 4)) @ok{4}
(make-string 4 @char{g})             @ok{"gggg"}
@end lisp

@lisp
(make-string 4 @string{g}) @exception{type}
(make-string 4.5)   @exception{type}
(make-string -1)    @exception{range}
@end lisp
@end deftypefn

@deftypefn scheme/base {} string char@dots{}
Returns a newly allocated string whose elements are @var{char}@enddots{}
The order of the arguments is preserved.  Analogous to @code{list}
(@pxref{Pair and list procedures}).

@lisp
(string)                               @ok{""}
(string @char{G} @char{a} @char{m} @char{b} @char{i} @char{t})       @ok{"Gambit"}
(apply string (string->list @string{Gambit})) @ok{"Gambit"}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-length string
Returns the number of characters in @var{string}.

@lisp
(string-length (make-string 5)) @ok{5}
(string-length @string{})              @ok{0}
(string-length @string{lambda})        @ok{6}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-ref string k
Returns the character at index @var{k} of @var{string}.  If @var{k} is
not a valid index of @var{string}, an exception that satisfies
@code{range-exception?} is raised.

@lisp
(@syntax{define} s @string{off by one})
(string-ref @string{zero-origin indexing} 0)  @ok{#\z}
(string-ref s (- (string-length s) 1)) @ok{#\e}
(string-ref s (string-length s))       @exception{range}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string=? string@dots{}
Returns @code{#t} if all @var{string} arguments are the same length and
contain exactly the same characters in the same positions.

Gambit extends the @value{R7RS} description of @code{string=?} to accept
any number of arguments.

@lisp
(string=? @string{abc} (string @char{a} @char{b} @char{c})) @value{true}
(string=? @string{abcd} @string{Abcd})              @value{false}
(string=?)                            @value{true}
(string=? (string))                   @value{true}
(string=? @string{a} @string{a} @string{a})                @value{true}
(string=? @string{a} @char{a})                    @exception{type}
@end lisp
@end deftypefn

@deftypefn  scheme/base @/ string<? string@dots{}
@deftypefnx scheme/base @/ string>? string@dots{}
@deftypefnx scheme/base @/ string<=? string@dots{}
@deftypefnx scheme/base @/ string>=? string@dots{}
These predicates return @code{#t} if their @var{string} arguments are
(respectively): monotonically increasing, monotonically decreasing,
monotonically non-decreasing, or monotonically non-increasing.  They are
transitive.

A pair of strings satisfies exactly one of @code{string<?},
@code{string=?}, and @code{string>?}.  They may satisfy @code{string<=?}
if and only if they do not satisfy @code{string>?}.  They may satisfy
@code{string>=?} if and only if they do not satisfy @code{string<?}.

Gambit extends the @value{R7RS} descriptions of these procedures to
accept any number of arguments.

@lisp
(string<=? @string{g} @string{g}) @value{false}
(string>=? @string{g} @string{g}) @value{false}
(string<?  @string{g} @string{g}) @value{false}
(string>?  @string{g} @string{g}) @value{false}

(string<? @string{G} @string{g})  @value{true}
(string>? @string{G} @string{g})  @value{false}

(string<? @string{gg} @string{g}) @value{false}
(string>? @string{gg} @string{g}) @value{true}
@end lisp
@end deftypefn

@deftypefn  scheme/char @/ string-ci=? string@dots{}
@deftypefnx scheme/char @/ string-ci<? string@dots{}
@deftypefnx scheme/char @/ string-ci>? string@dots{}
@deftypefnx scheme/char @/ string-ci<=? string@dots{}
@deftypefnx scheme/char @/ string-ci>=? string@dots{}
Each of these predicates behaves as if @code{string-foldcase} were
applied to each @var{string} and then that predicate's non-@samp{-ci}
counterpart were applied to those case-folded arguments.

@lisp
(string-ci=?  @string{G} @string{g})                             @value{true}
(apply string=? (map string-foldcase '(@string{G} @string{g})))  @value{true}
@end lisp

@lisp
(string-ci>=? @string{G} @string{g})                             @value{true}
(apply string<=? (map string-foldcase '(@string{G} @string{g}))) @value{true}
@end lisp

@lisp
(string-ci<=? @string{g} @string{G})                             @value{true}
(apply string<=? (map string-foldcase '(@string{g} @string{G}))) @value{true}
@end lisp

@lisp
(string-ci<?  @string{G} @string{g})                             @value{false}
(apply string<? (map string-foldcase '(@string{G} @string{g})))  @value{false}
@end lisp

@lisp
(string-ci>?  @string{g} @string{G})                             @value{false}
(apply string>? (map string-foldcase '(@string{g} @string{G})))  @value{false}
@end lisp
@end deftypefn

@deftypefn scheme/char @/ string-upcase string
@deftypefnx scheme/char @/ string-downcase string
@deftypefnx scheme/char @/ string-foldcase string
These procedures apply the Unicode full string uppercasing, lowercasing,
and case-folding algorithms to their arguments and return the result.
In certain cases, the result differs in length from @var{string}.  Note
that language-sensitive mappings and foldings are not used.

@set Etoc @U{0388}@U{03C4}@U{03BF}@U{03C2}
@set etoc @U{03AD}@U{03C4}@U{03BF}@U{03C2}
@set etoo @U{03AD}@U{03C4}@U{03BF}@U{03C3}
@set ETOS @U{0388}@U{03A4}@U{039F}@U{03A3}
@set WeiB Wei@ss{}
@set weiB wei@ss{}
@lisp
(string-downcase @string{@value{Etoc}}) @ok{"@value{etoc}"}
(string-foldcase @string{@value{Etoc}}) @ok{"@value{etoo}"}
(string-upcase   @string{@value{Etoc}}) @ok{"@value{ETOS}"}
(string-downcase @string{@value{ETOS}}) @ok{"@value{etoo}"}
(string-foldcase @string{@value{ETOS}}) @ok{"@value{etoo}"}
@end lisp

@lisp
(string-downcase @string{@value{WeiB}})  @ok{"@value{weiB}"}
(string-foldcase @string{@value{WeiB}})  @ok{"weiss"}
(string-upcase   @string{@value{WeiB}})  @ok{"WEISS"}
(string-downcase @string{WEISS}) @ok{"weiss"}
(string-foldcase @string{WEISS}) @ok{"weiss"}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-append string@dots{}

Returns a newly allocated string whose characters are the concatenation
of the characters in the given @var{strings}.

@lisp
(string-append)                    @ok{""}
(string-append @string{})                 @ok{""}
(string-append @string{hello} @string{world})    @ok{"helloworld"}
(string-append @string{hello} @string{} @string{world}) @ok{"helloworld"}
(string-append @string{hello } @string{ world})   @ok{"hello  world"}
(string-append @string{hello} @string{ } @string{world}) @ok{"hello world"}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string->list string @opt{start @opt{end}}
Returns a newly allocated list of characters in @var{string}.  In the
one-argument form, the returned list comprises all characters of
@var{string}.  In the two-argument form, the returned list comprises
characters from index @var{start} (inclusive) through the end of
@var{string}.  In the three-argument form, the returned list comprises
characters from index @var{start} (inclusive) through index @var{end}
(exclusive).

Order is preserved.  @code{string->list} and @code{list->string} are
inverses so far as @code{equal?} is concerned.  If either @var{start} or
@var{end} is not a valid index of @var{string}, an exception that
satisfies @code{range-exception?} is raised.

@lisp
(string->list @string{scheme})     @ok{(#\s #\c #\h #\e #\m #\e)}
(string->list @string{scheme} 1)   @ok{(#\c #\h #\e #\m #\e)}
(string->list @string{scheme} 2 6) @ok{(#\h #\e #\m #\e)}
(string->list @string{scheme} 6)   @ok{()}
(string->list @string{scheme} 6 6) @ok{()}
@end lisp

@lisp
(string->list @string{scheme} 7)   @exception{range}
(string->list @string{scheme} 3 7) @exception{range}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ list->string list
Returns a newly allocated string formed from the elements in @var{list}.

Order is preserved.  @code{list->string} and @code{string->list} and are
inverses so far as @code{equal?} is concerned.  If any element of
@var{list} is not a character, an exception that satisfies @code{type?}
is raised.

@lisp
(list->string (list))                       @ok{""}
(list->string '(@char{s} @char{c} @char{h} @char{e} @char{m} @char{e}))   @ok{"scheme"}
(list->string '(@char{s} @char{c} @char{h} @char{e} @char{m} @char{e} 2)) @exception{type}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-copy string @opt{start @opt{end}}
Returns a newly allocated string whose value is a portion of
@var{string}.  In the one-argument form, the returned portion is all of
@var{string}.  In the two-argument form, the returned string is a copy
of @var{string} from index @var{start} (inclusive) through the end of
@var{string}.  In the three-argument form, the returned string is a copy
of @var{string} from index @var{start} (inclusive) to index @var{end}
(exclusive).

Order is preserved.  @code{string->list} and @code{list->string} and are
inverses so far as @code{equal?} is concerned.  If either @var{start} or
@var{end} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If either @var{start} or @var{end} is
not a valid index of @var{string}, an exception that satisfies
@code{range-exception?} is raised.

@lisp
(string-copy @string{dwim})                          @ok{"dwim"}
(string-copy @string{dwim} 0)                        @ok{"dwim"}
(string-copy @string{dwim} 1)                        @ok{"wim"}
(string-copy @string{dwim} 1 1)                      @ok{""}
(string-copy @string{dwim} 0 (string-length @string{dwim})) @ok{"dwim"}
(eqv?     @string{dwim} (string-copy @string{dwim}))        @value{false}
(string=? @string{dwim} (string-copy @string{dwim}))        @value{true}
@end lisp

@lisp
(string-copy @string{dwim} 5)    @exception{range}
(string-copy @string{dwim} -1 3) @exception{range}
(string-copy @string{dwim} 2 5)  @exception{range}
(string-copy @string{dwim} 2.5)  @exception{type}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-copy! to-string at from-string @opt{start @opt{end}}

Mutates @var{to-string} by copying a substring of @var{from-string} into
@var{to-string}, beginning with index @var{at} of @var{to-string}.  In
the three-argument form, all of @var{from-string} is copied.  In the
four-argument form, the value of @samp{(string-copy
@slanted{@var{from-string}} @slanted{@var{start}})} is copied.  In the
five-argument form, the value of @samp{(string-copy
@slanted{@var{from-string}} @slanted{@var{start}} @slanted{@var{end}})}
is copied.

If @var{at} is not a valid index of @var{to-string}, an exception that
satisfies @code{range-exception?} is raised.  If @samp{(- (string-length
@slanted{@var{to-string}}) @slanted{@var{at}})} is less than @samp{(-
@slanted{@var{end}} @slanted{@var{start}})}, an exception that satisfies
@code{range-exception?}  is raised (in other words, the copied substring
must not overflow beyond the end of @var{to-string}).

@lisp
(@syntax{define} a @string{12345})
(@syntax{define} b (string-copy @string{abcde}))
(string-copy! b 1 a 0 2)
b @ok{"a12de"}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-fill! string char @opt{start @opt{end}}
Mutates @var{string} by overwriting some or all of its elements with
@var{char}.  In the two-argument form, each element is overwritten.  In
the three-argument form, the elements from index @var{start} (inclusive)
through the end of @var{string} are overwritten.  In the four-argument
form, the elements from index @var{start} (inclusive) to index @var{end}
(exclusive) are overwritten.

If either @var{start} or @var{end} is not a valid index of @var{string},
an exception that satisfies @code{range-exception?} is raised.

@lisp
(@syntax{define} a (string-copy @string{abcde}))
(@syntax{define} b (string-copy a))
(@syntax{define} c (string-copy b))
(string-fill! a @char{0})
(string-fill! b @char{0} 3)
(string-fill! c @char{0} 3 4)
a @ok{"00000"}
b @ok{"abc00"}
c @ok{"abc0e"}
@end lisp
@end deftypefn

@deftypefn scheme/base @/ string-set! string k char
Mutates @var{string} by storing @var{char} in element @var{k} of
@var{string}.

If @var{string} is not a mutable string, an exception that satisfies
@code{type-exception?} is raised.  If @var{k} is not an exact integer,
an exception that satisfies @code{type-exception?} is raised.  If
@var{k} is not a valid index of @var{string}, an exception that
satisfies @code{range-exception?} is raised.

@lisp
(@syntax{define} (f) (make-string 3 @char{*}))
(string-set! (f) 0 @char{?}) @aside{;; ok}
(string-set! (f) 5 @char{?})   @exception{range}
(string-set! (f) 1.1 @char{?}) @exception{type}
@end lisp

@lisp
(string-set! (symbol->string 'immutable) 0 @char{?}) @exception{type}
@end lisp

@lisp
(@syntax{define} (g) @string{***})
(string-set! (g) 0 @char{?}) @aside{;; @value{R7RS} says this is an error}
(g) @ok{"?**"}             @aside{;; current Gambit behavior} 
@end lisp
@end deftypefn
