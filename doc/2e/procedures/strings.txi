@
@deffn  procedure caar pair
@deffnx procedure cadr pair
@deffnx procedure cdar pair
@deffnx procedure cddr pair

These procedures are compositions of @code{car} and @code{cdr} as
follows:

@lisp
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))
@end lisp

@end deffn
@deffn  {cxr library procedure} caaar @var{pair}
@deffnx {cxr library procedure} caadr @var{pair}
@end deffn
@deffn  {cxr library procedure} cdddar @var{pair}
@deffnx {cxr library procedure} cddddr @var{pair}

These twenty-four procedures are further compositions of @code{car} and
@code{cdr} on the same principles. For example, @code{caddr} could be
defined by

@lisp
(define caddr (lambda (x) (car (cdr (cdr x))))).
@end lisp

Arbitrary compositions up to four deep are provided.

@end deffn
@deffn procedure null? obj

@cindex empty list

Returns @code{#t} if @var{obj} is the empty list,
otherwise returns @code{#f}.

@end deffn
@deffn procedure list? obj

Returns @code{#t} if @var{obj} is a list. Otherwise, it returns
@code{#f}. By definition, all lists have finite length and are
terminated by the empty list.

@lisp
(list? '(a b c))     @result{} #t
(list? '())          @result{} #t
(list? '(a . b))     @result{} #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))         @result{} #f
@end lisp

@end deffn
@deffn  procedure make-list k
@deffnx procedure make-list k fill

Returns a newly allocated list of @var{k} elements. If a second
argument is given, then each element is initialized to @var{fill}.
Otherwise the initial contents of each element is unspecified.

@lisp
(make-list 2 3) @result{} (3 3)
@end lisp

@end deffn
@deffn procedure list obj @dots{}

Returns a newly allocated list of its arguments.

@lisp
(list 'a (+ 3 4) 'c) @result{} (a 7 c)
(list)               @result{} ()
@end lisp

@end deffn
@deffn procedure length list

Returns the length of @var{list}.

@lisp
(length '(a b c))         @result{} 3
(length '(a (b) (c d e))) @result{} 3
(length '())              @result{} 0
@end lisp

@end deffn
@deffn procedure append list@dots{}

The last argument, if there is one, can be of any type.

Returns a list consisting of the elements of the first @var{list}
followed by the elements of the other @var{lists}. If there are no
arguments, the empty list is returned. If there is exactly one
argument, it is returned. Otherwise the resulting list is always newly
allocated, except that it shares structure with the last argument. An
improper list results if the last argument is not a proper list.

@lisp
(append '(x) '(y))       @result{} (x y)
(append '(a) '(b c d))   @result{} (a b c d)
(append '(a (b)) '((c))) @result{} (a (b) (c))

(append '(a b) '(c . d)) @result{} (a b c . d)
(append '() 'a)          @result{} a
@end lisp

@end deffn
@deffn procedure reverse list

Returns a newly allocated list consisting of the elements of @var{list}
in reverse order.

@lisp
(reverse '(a b c))             @result{} (c b a)
(reverse '(a (b c) d (e (f)))) @result{} ((e (f)) d (b c) a)
@end lisp

@end deffn
@deffn procedure list-tail list k

It is an error if @var{list} has fewer than @var{k} elements.

Returns the sublist of @var{list} obtained by omitting the first
@var{k} elements. The @code{list-tail} procedure could be defined by

@lisp
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))
@end lisp

@end deffn
@deffn procedure list-ref list k

The @var{list} argument can be circular, but it is an error if @var{list}
has @var{k} or fewer elements.

Returns the @var{k}th element of @var{list}. (This is the same as the
car of @code{(list-tail }@var{list} @var{k}@code{)}.)

@lisp
(list-ref '(a b c d) 2)                   @result{} c
(list-ref '(a b c d) (exact (round 1.8))) @result{} c
@end lisp

@end deffn
@deffn procedure list-set! list k obj

It is an error if @var{k} is not a valid index of @var{list}.

The @code{list-set!} procedure stores @var{obj} in element @var{k} of
@var{list}.

@lisp
(let ((ls (list 'one 'two 'five!)))
  (list-set! ls 2 'three)
  ls) @result{} (one two three)

(list-set! '(0 1 2) 1 "oops") @result{} @r{error}  ; constant list
@end lisp
@end deffn
@deffn  procedure memq obj list
@deffnx procedure memv obj list
@deffnx procedure member obj list
@deffnx procedure member obj list compare

These procedures return the first sublist of @var{list} whose car is
@var{obj}, where the sublists of @var{list} are the non-empty lists
returned by @code{(list-tail }@var{list} @var{k}@code{)} for @var{k}
less than the length of @var{list}. If @var{obj} does not occur in
@var{list}, then @code{#f} (not the empty list) is returned. The
@code{memq} procedure uses @code{eq?} to compare @var{obj} with the
elements of @var{list}, while @code{memv} uses @code{eqv?} and
@code{member} uses @var{compare}, if given, and @code{equal?}
otherwise.

@lisp
(memq 'a '(a b c))          @result{} (a b c)
(memq 'b '(a b c))          @result{} (b c)
(memq 'a '(b c d))          @result{} #f
(memq (list 'a) '(b (a) c)) @result{} #f
(member (list 'a)
        '(b (a) c))         @result{} ((a) c)
(member "B"
        '("a" "b" "c")
        string-ci=?)        @result{} ("b" "c")
(memq 101 '(100 101 102))   @result{} @r{unspecified}
(memv 101 '(100 101 102))   @result{} (101 102)
@end lisp

@end deffn
@deffn  procedure assq obj alist
@deffnx procedure assv obj alist
@deffnx procedure assoc obj alist
@deffnx procedure assoc obj alist compare

It is an error if @var{alist} (for ``association list'') is not a list
of pairs.

These procedures find the first pair in @var{alist} whose car field
is @var{obj}, and returns that pair.  If no pair in @var{alist} has
@var{obj} as its car, then @code{#f} (not the empty list) is returned.
The @code{assq} procedure uses @code{eq?} to compare @var{obj} with the
car fields of the pairs in @var{alist}, while @code{assv} uses @code{eqv?}
and @code{assoc} uses @var{compare} if given and @code{equal?} otherwise.

@lisp
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                            @result{} (a 1)
(assq 'b e)                            @result{} (b 2)
(assq 'd e)                            @result{} #f
(assq (list 'a) '(((a)) ((b)) ((c))))  @result{} #f
(assoc (list 'a) '(((a)) ((b)) ((c)))) @result{} ((a))
(assoc 2.0 '((1 1) (2 4) (3 9)) =)     @result{} (2 4)
(assq 5 '((2 3) (5 7) (11 13)))        @result{} @r{unspecified}
(assv 5 '((2 3) (5 7) (11 13)))        @result{} (5 7)
@end lisp

@end deffn
@deffn procedure list-copy obj

Returns a newly allocated copy of the given @var{obj} if it is a list.
Only the pairs themselves are copied; the cars of the result are the same
(in the sense of @code{eqv?}) as the cars of @var{list}.  If @var{obj}
is an improper list, so is the result, and the final cdrs are the same in
the sense of @code{eqv?}.  An @var{obj} which is not a list is returned
unchanged.  It is an error if @var{obj} is a circular list.

@lisp
(define a '(1 8 2 8)) ; a may be immutable
(define b (list-copy a))
(set-car! b 3)        ; b is mutable
b @result{} (3 8 2 8)
a @result{} (1 8 2 8)
@end lisp

@end deffn
