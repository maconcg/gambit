@node Pair and list procedures
@chapter Pair and list procedures

@deftypefn @t{(scheme base)} @/ pair? obj
Returns @code{#t} if @var{obj} is a pair.

@lisp
(pair? '(a . b)) @result{} #t
(pair? '(a b c)) @result{} #t
(pair? '())      @result{} #f
(pair? '(() ())) @result{} #f
(pair? '#(a b))  @result{} #f
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ cons @pari{obj} @parii{obj}
Returns a newly allocated pair whose car is @vari{obj} and whose cdr is
@varii{obj}.  The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every existing object.

@lisp
(cons 'a '())                      @result{} (a)
(cons '(a) '(b c d))               @result{} ((a) b c d)
(cons "a" '(b c))                  @result{} ("a" b c)
(cons 'a 3)                        @result{} (a . 3)
(cons '(a b) 'c)                   @result{} ((a b) . c)
(eq? cons (cdr (cons cons cons)))  @result{} #t
(eqv?   (cons + car) (cons + car)) @result{} #f
(equal? (cons + car) (cons + car)) @result{} #t
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ car pair
@tindex empty list
Returns the contents of the cdr field of @var{pair}.  If an attempt is
made to take the car of the empty list, an exception that satisfies
@code{type-exception?} is raised.

@lisp
(car '(a b c))     @result{} a
(car '((a) b c d)) @result{} (a)
(car '(1 . 2))     @result{} 1
(car '())          @exception{type}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ cdr pair
Returns the contents of the cdr field of @var{pair}.  If an attempt is
made to take the cdr of the empty list, an exception that satisfies
@code{type-exception?} is raised.

@lisp
(cdr '(a b c))     @result{} (b c)
(cdr '((a) b c d)) @result{} (b c d)
(cdr '(1 . 2))     @result{} 2
(cdr '())          @exception{type}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ set-car! pair obj
Mutates @var{pair} by storing @var{obj} in the car field of @var{pair}.

@lisp
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))

(set-car! (f) 3) @slanted{;; legal, but useless}
(f)              @result{} (not-a-constant-list)
(set-car! (g) 3) @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ set-cdr! pair obj
Mutates @var{pair} by storing @var{obj} in the cdr field of @var{pair}.

@lisp
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))

(set-cdr! (f) 3) @slanted{;; legal, but useless}
(f)              @result{} (not-a-constant-list)
(set-cdr! (g) 3) @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn  @t{(scheme cxr)} @/ caar pair
@deftypefnx @t{(scheme cxr)} @/ cadr pair
@deftypefnx @t{(scheme cxr)} @/ cdar pair
@deftypefnx @t{(scheme cxr)} @/ cddr pair
@deftypefnx @t{(scheme cxr)} @/ caaar pair
@deftypefnx @t{(scheme cxr)} @/ caadr pair
@deftypefnx @t{(scheme cxr)} @/ cadar pair
@deftypefnx @t{(scheme cxr)} @/ caddr pair
@deftypefnx @t{(scheme cxr)} @/ cdaar pair
@deftypefnx @t{(scheme cxr)} @/ cdadr pair
@deftypefnx @t{(scheme cxr)} @/ cddar pair
@deftypefnx @t{(scheme cxr)} @/ cdddr pair
@deftypefnx @t{(scheme cxr)} @/ caaaar pair
@deftypefnx @t{(scheme cxr)} @/ caaadr pair
@deftypefnx @t{(scheme cxr)} @/ caadar pair
@deftypefnx @t{(scheme cxr)} @/ caaddr pair
@deftypefnx @t{(scheme cxr)} @/ cadaar pair
@deftypefnx @t{(scheme cxr)} @/ cadadr pair
@deftypefnx @t{(scheme cxr)} @/ caddar pair
@deftypefnx @t{(scheme cxr)} @/ cadddr pair
@deftypefnx @t{(scheme cxr)} @/ cdaaar pair
@deftypefnx @t{(scheme cxr)} @/ cdaadr pair
@deftypefnx @t{(scheme cxr)} @/ cdadar pair
@deftypefnx @t{(scheme cxr)} @/ cdaddr pair
@deftypefnx @t{(scheme cxr)} @/ cddaar pair
@deftypefnx @t{(scheme cxr)} @/ cddadr pair
@deftypefnx @t{(scheme cxr)} @/ cdddar pair
@deftypefnx @t{(scheme cxr)} @/ cddddr pair

These procedures are compositions of @code{car} and @code{cdr}.

@lisp
(define l '((a b) (c) d (e (f) g)))
(define circle (circular-list 'a 'b 'c))

(cadr l)             @result{} (c)
(car (cdr l))        @result{} (c)
(cddr '(a b c . d))  @result{} (c . d)
(cdddr '(a b c . d)) @result{} d
(cdadr l)            @result{} ()
(cdar (cdr l))       @result{} ()
(caar (cdr l))       @result{} c
(car (car (cdr l)))  @result{} c
(cadddr l)           @result{} (e (f) g)
(caaadr l)           @exception{type}

(car circle)         @result{} a
(cadr circle)        @result{} b
(caddr circle)       @result{} c
(cadddr circle)      @result{} a
@end lisp
@end deftypefn

@cindex empty list
@deftypefn @t{(scheme base)} @/ null? obj
Returns @code{#t} if @var{obj} is the empty list.

@lisp
(null? '())    @result{} #t
(null? (list)) @result{} #t
(null? #\null) @result{} #f
(null? null?)  @result{} #f
(null? #f)     @result{} #f
(null? 0)      @result{} #f
(null? "")     @result{} #f
(null? #())    @result{} #f
(null? (void)) @result{} #f
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list? obj
Returns @code{#t} if @var{obj} is a @dfn{proper list}.  By definition, a
list of finite length is terminated by the empty list.

@lisp
(list? '(a b c))     @result{} #t
(list? '())          @result{} #t
(list? '(a . b))     @result{} #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))         @result{} #f
(list? list)         @result{} #f
(list? "list")       @result{} #f
(list? #(0 1 2))     @result{} #f
@end lisp
@end deftypefn

@deftypefn  @t{(scheme base)} @/ make-list k
@deftypefnx @t{(scheme base)} @/ make-list k fill
Returns a newly allocated list of @var{k} elements.  In the one-argument
form, each element is initialized to a default value.  In the
two-argument form, each element is initialized to @var{fill}.

The default value used by the one-argument form may change in a future
version.  Programs that require a specific initilization value should
use the two-argument form.

If @var{k} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If @var{k} is a negative exact
integer, an exception that satisfies @code{range-exception?} is raised.

@lisp
(make-list 0)        @result{} ()
(make-list 3 (list)) @result{} (() () ())
(make-list 1.25)     @exception{type}
(make-string -1)     @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list obj@dots{}
Returns a newly allocated list consisting of its arguments.

@lisp
(list 'a (+ 3 4) 'c)      @result{} (a 7 c)
(list)                    @result{} ()
((car (list list)) 'list) @result{} (list)
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ length list
Returns the length of @var{list}.

@lisp
(define circle (circular-list 'x 'y 'z))

(length '(a b c))            @result{} 3
(length '(a (b) (c d e)))    @result{} 3
(length '())                 @result{} 0
(length (cdr (make-list 5))) @result{} 4
(length circle)              @arrow{} @r{@i{infinite loop}}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ append list@dots{} [obj]
The zero-argument form returns the empty list.  The one-argument form
returns its argument, whatever that argument's type.  Each argument
except the last, if present, must be a list.

With two or more arguments, the returned value consists of the elements
of each list@dots{}, in order (excluding each @var{list}'s terminating
empty list).  A proper list is returned if @var{obj} is a proper list;
an improper list is returned if if @var{obj} is not a proper list.  The
returned value is newly allocated, except that it shares structure with
the last argument, @var{obj}.

@lisp
(define l (list 'f 'g 'h))

(eq?    l (append (append) l)) @result{} #t
(eq?    l (append l (append))) @result{} #f
(equal? l (append l (append))) @result{} #t

(append '(x) '(y))              @result{} (x y)
(append '(a) '(b c d))          @result{} (a b c d)
(append '(a (b)) '((c)))        @result{} (a (b) (c))

(append '(a b) '(c . d))        @result{} (a b c . d)
(append '() 'a)                 @result{} a
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ reverse list
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order (excluding the terminating empty list).

@lisp
(define l (list 'a 'b 'c))

(eq?    l (reverse (reverse l))) @result{} #f
(equal? l (reverse (reverse l))) @result{} #t

(reverse '(a b c))             @result{} (c b a)
(reverse '(a (b c) d (e (f)))) @result{} ((e (f)) d (b c) a)
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-tail list k
Returns a list of @var{list} obtained by omitting the first @var{k}
elements.  If @var{list} is a proper list, a proper list is returned; if
@var{list} is an improper list, an improper list is returned.

If @var{k} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If @var{list} has fewer than @var{k}
elements, an exception that satisfies @code{range-exception?} is raised.

@lisp
(list-tail '(a b c) 1)   @result{} (b c)
(list-tail '(a b c) 3)   @result{} ()
(list-tail '(a b c) 1.1) @exception{type}
(list-tail '(a b c) 4)   @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-ref list k
Returns element @var{k} of @var{list}.  Equivalent to @samp{(car
(list-tail @slanted{list} @slanted{k}))}.  The @var{list} argument may
be circular.

@lisp
(list-ref '(a b c d) 2)                   @result{} c
(list-ref '(a b c d) (exact (round 1.8))) @result{} c
(list-ref (circular-list 'a 'b 'c) 4) @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-set! list k obj
Mutates @var{list} by storing @var{obj} in element @var{k} of
@var{list}.  It is an error if @var{k} is not a valid index of
@var{list}.

@lisp
(let ((ls (list 'one 'two 'five!)))
  (list-set! ls 2 'three)
  ls) @result{} (one two three)

(list-set! '(0 1 2) 1 "oops") @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn  @t{(scheme base)} @/ memq   obj list
@deftypefnx @t{(scheme base)} @/ memv   obj list
@deftypefnx @t{(scheme base)} @/ member obj list [compare]
Each procedure successively applies some procedure to each element of
@var{list} and returns the first sublist of @var{list} whose car
satisfies that test relative to @var{obj}.  They differ only in the
procedure that is used.  If no element of @var{list} satisfies the test,
@code{#f} is returned.

In each two-argument form, a standard equivalence predicate is used.  In
the three-argument form of @code{@slanted{member}}, @var{compare} may
return a non-Boolean value.

@itemize @bullet
@item
@code{memq} uses @code{@slanted{eq?}}
@item
@code{memv} uses @code{@slanted{eqv?}}
@item
@code{member} uses @code{@slanted{equal?}} in the two-argument form.
@item
@code{member} uses @var{compare} in the three-argument form.
@end itemize

@lisp
(define nums '(100 101 102))

(memq 101 nums)        @result{} @r{@i{unspecified}}
(memv 101 nums)        @result{} (101 102)
(member 7 nums +)      @result{} (100 101 102)
(member 7 nums square) @exception{wrong number of arguments}

(memq 'a '(a b c))                      @result{} (a b c)
(memq 'b '(a b c))                      @result{} (b c)
(memq 'a '(b c d))                      @result{} #f
(memq (list 'a) '(b (a) c))             @result{} #f
(memq 'a '(a b c))                      @result{} (a b c)
(member (list 'a) '(b (a) c))           @result{} ((a) c)
(member "B" '("a" "b" "c") string-ci=?) @result{} ("b" "c")
@end lisp
@end deftypefn

@deftypefn  @t{(scheme base)} @/ assq obj  alist
@deftypefnx @t{(scheme base)} @/ assv obj  alist
@deftypefnx @t{(scheme base)} @/ assoc obj alist [compare]

Each procedure successively applies some procedure to the elements of
@var{alist} returns the first pair of @var{alist} whose car satisfies
that test relative to @var{obj}.  They differ only in the procedure that
is used.  If none of @var{alist}'s elements' cars satisfies the test,
@code{#f} is returned.

In each two-argument form, a standard equivalence predicate is used.  In
the three-argument form of @code{@slanted{assoc}}, @var{compare} may
return a non-Boolean value.

@itemize @bullet
@item
@code{assq} uses @code{@slanted{eq?}}
@item
@code{assv} uses @code{@slanted{eqv?}}
@item
@code{assoc} uses @code{@slanted{equal?}} in the two-argument form.
@item
@code{assoc} uses @var{compare} in the three-argument form.
@end itemize

@lisp
(define e '((a 1) (b 2) (c 3)))

(assq 'a e)                            @result{} (a 1)
(assq 'b e)                            @result{} (b 2)
(assq 'd e)                            @result{} #f
(assq (list 'a) '(((a)) ((b)) ((c))))  @result{} #f
(assoc (list 'a) '(((a)) ((b)) ((c)))) @result{} ((a))
(assoc 2.0 '((1 1) (2 4) (3 9)) =)     @result{} (2 4)
(assq 5 '((2 3) (5 7) (11 13)))        @result{} @r{unspecified}
(assv 5 '((2 3) (5 7) (11 13)))        @result{} (5 7)
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-copy obj
Returns a newly allocated copy of the given @var{obj} if it is a list.
Only the pairs themselves are copied; the cars of the result are the
same (in the sense of @code{eqv?}) as the cars of @var{list}.  If
@var{obj} is an improper list, so is the result, and the final cdrs are
the same in the sense of @code{eqv?}.  An @var{obj} which is not a list
is returned unchanged.  It is an error if @var{obj} is a circular list.

@lisp
(define circle (circular-list 0 1 2 3))
(define a '(1 8 2 8)) @slanted{;; a may be immutable}
(define b (list-copy a))

(set-car! b 3)     @slanted{;; b is mutable}
b                  @result{} (3 8 2 8)
a                  @result{} (1 8 2 8)

(list-copy circle) @arrow{} @r{@i{infinite loop}}
@end lisp
@end deftypefn
