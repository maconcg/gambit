@node Pair and list procedures
@chapter Pair and list procedures

@tindex pair @subentry @r{predicate} @subentry pair?
@deftypefn @t{(scheme base)} @/ pair? obj
Returns @code{#t} if @var{obj} is a pair.

@lisp
(pair? '(a . b)) @value{true}
(pair? '(a b c)) @value{true}
(pair? '())      @value{false}
(pair? '(() ())) @value{false}
(pair? '#(a b))  @value{false}
@end lisp
@end deftypefn

@cindex cons @subentry @code{cons} procedure
@tindex pair @subentry @r{constructor} @subentry cons
@deftypefn @t{(scheme base)} @/ cons @pari{obj} @parii{obj}
Returns a newly allocated pair whose car is @vari{obj} and whose cdr is
@varii{obj}.  The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every existing object.

@lisp
(cons 'a '())        @ok{(a)}
(cons '(a) '(b c d)) @ok{((a) b c d)}
(cons "a" '(b c))    @ok{("a" b c)}
(cons 'a 3)          @ok{(a . 3)}
(cons '(a b) 'c)     @ok{((a b) . c)}
@end lisp
@lisp
(eqv?   (cons + car) (cons + car)) @value{false}
(equal? (cons + car) (cons + car)) @value{true}
@end lisp
@lisp
(eq? cons (cdr (cons cons cons))) @value{true}
@end lisp
@end deftypefn

@cindex car @subentry @code{car} procedure
@tindex pair @subentry @r{selectors} @subentry car
@deftypefn @t{(scheme base)} @/ car pair
Returns the contents of the cdr field of @var{pair}.  If an attempt is
made to take the car of the empty list, an exception that satisfies
@code{type-exception?} is raised.

@lisp
(car '(a b c))     @ok{a}
(car '((a) b c d)) @ok{(a)}
(car '(1 . 2))     @ok{1}
(car '())          @exception{type}
@end lisp
@end deftypefn

@cindex cdr @subentry @code{cdr} procedure
@tindex pair @subentry @r{selectors} @subentry cdr
@deftypefn @t{(scheme base)} @/ cdr pair
Returns the contents of the cdr field of @var{pair}.  If an attempt is
made to take the cdr of the empty list, an exception that satisfies
@code{type-exception?} is raised.

@lisp
(cdr '(a b c))     @ok{(b c)}
(cdr '((a) b c d)) @ok{(b c d)}
(cdr '(1 . 2))     @ok{2}
(cdr '())          @exception{type}
@end lisp
@end deftypefn

@tindex pair @subentry @r{mutators} @subentry set-car!
@deftypefn @t{(scheme base)} @/ set-car! pair obj
Mutates @var{pair} by storing @var{obj} in the car field of @var{pair}.

@lisp
(define (f) (list 'not-a-constant-list))
(set-car! (f) 3)

(f) @ok{(not-a-constant-list)}
@end lisp
@lisp
(define (g) '(constant-list))
(set-car! (g) 3) @aside{;; @value{R7RS} says this is an error}

(g) @ok{(3)}        @aside{;; current Gambit behavior}
@end lisp
@end deftypefn

@tindex pair @subentry @r{mutators} @subentry set-cdr!
@deftypefn @t{(scheme base)} @/ set-cdr! pair obj
Mutates @var{pair} by storing @var{obj} in the cdr field of @var{pair}.

@lisp
(define (f) (list 'not-a-constant-list))
(set-cdr! (f) 3)

(f) @ok{(not-a-constant-list)}
@end lisp
@lisp
(define (g) '(constant-list))
(set-cdr! (g) 3)          @aside{;; @value{R7RS} says this is an error}

(g) @ok{(constant-list . 3)} @aside{;; current Gambit behavior}
@end lisp
@end deftypefn

@tindex pair @subentry @r{selectors} @subentry (scheme cxr) @r{library} @sortas{s}
@deftypefn  @t{(scheme cxr)} @/ caar pair
@deftypefnx @t{(scheme cxr)} @/ cadr pair
@deftypefnx @t{(scheme cxr)} @/ cdar pair
@deftypefnx @t{(scheme cxr)} @/ cddr pair
@deftypefnx @t{(scheme cxr)} @/ caaar pair
@deftypefnx @t{(scheme cxr)} @/ caadr pair
@deftypefnx @t{(scheme cxr)} @/ cadar pair
@deftypefnx @t{(scheme cxr)} @/ caddr pair
@deftypefnx @t{(scheme cxr)} @/ cdaar pair
@deftypefnx @t{(scheme cxr)} @/ cdadr pair
@deftypefnx @t{(scheme cxr)} @/ cddar pair
@deftypefnx @t{(scheme cxr)} @/ cdddr pair
@deftypefnx @t{(scheme cxr)} @/ caaaar pair
@deftypefnx @t{(scheme cxr)} @/ caaadr pair
@deftypefnx @t{(scheme cxr)} @/ caadar pair
@deftypefnx @t{(scheme cxr)} @/ caaddr pair
@deftypefnx @t{(scheme cxr)} @/ cadaar pair
@deftypefnx @t{(scheme cxr)} @/ cadadr pair
@deftypefnx @t{(scheme cxr)} @/ caddar pair
@deftypefnx @t{(scheme cxr)} @/ cadddr pair
@deftypefnx @t{(scheme cxr)} @/ cdaaar pair
@deftypefnx @t{(scheme cxr)} @/ cdaadr pair
@deftypefnx @t{(scheme cxr)} @/ cdadar pair
@deftypefnx @t{(scheme cxr)} @/ cdaddr pair
@deftypefnx @t{(scheme cxr)} @/ cddaar pair
@deftypefnx @t{(scheme cxr)} @/ cddadr pair
@deftypefnx @t{(scheme cxr)} @/ cdddar pair
@deftypefnx @t{(scheme cxr)} @/ cddddr pair
These 28 procedures are compositions of @code{car} and @code{cdr}.

@lisp
(define l '((a b) (c) d (e (f) g)))
(cadr l)             @ok{(c)}
(car (cdr l))        @ok{(c)}
(cddr '(a b c . d))  @ok{(c . d)}
(cdddr '(a b c . d)) @ok{d}
(cdadr l)            @ok{()}
(cdar (cdr l))       @ok{()}
(caar (cdr l))       @ok{c}
(car (car (cdr l)))  @ok{c}
(cadddr l)           @ok{(e (f) g)}
(caaadr l)           @exception{type}
@end lisp
@lisp
(define circle (circular-list 'a 'b 'c))
(car circle)    @ok{a}
(cadr circle)   @ok{b}
(caddr circle)  @ok{c}
(cadddr circle) @ok{a}
@end lisp
@end deftypefn

@tindex empty list @subentry @r{predicate} @subentry null?
@deftypefn @t{(scheme base)} @/ null? obj
Returns @code{#t} if @var{obj} is the empty list.

@lisp
(null? '())    @value{true}
(null? (list)) @value{true}
(null? #\null) @value{false}
(null? null?)  @value{false}
(null? #f)     @value{false}
(null? 0)      @value{false}
(null? "")     @value{false}
(null? #())    @value{false}
(null? (void)) @value{false}
@end lisp
@end deftypefn

@tindex list @subentry @r{predicate} @subentry list?
@deftypefn @t{(scheme base)} @/ list? obj
Returns @code{#t} if @var{obj} is a proper list (@pxref{Pair and list
jargon}).  By definition, a list of finite length is terminated by the
empty list.

@lisp
(list? '(a b c)) @value{true}
(list? '())      @value{true}
(list? '(a . b)) @value{false}
(list? list)     @value{false}
(list? "list")   @value{false}
(list? #(0 1 2)) @value{false}
@end lisp
@lisp
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x)) @value{false}
@end lisp
@end deftypefn

@tindex list @subentry @r{constructors} @subentry make-list
@deftypefn  @t{(scheme base)} @/ make-list k
@deftypefnx @t{(scheme base)} @/ make-list k fill
Returns a newly allocated list of @var{k} elements.  In the one-argument
form, each element is initialized to a default value.  In the
two-argument form, each element is initialized to @var{fill}.

The default value used by the one-argument form may change in a future
version.  Programs that require a specific initialization value should
use the two-argument form.

If @var{k} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If @var{k} is a negative exact
integer, an exception that satisfies @code{range-exception?} is raised.

@lisp
(make-list 0)        @ok{()}
(make-list 3 (list)) @ok{(() () ())}
@end lisp
@lisp
(make-list 1.25)     @exception{type}
(make-string -1)     @exception{range}
@end lisp
@end deftypefn

@cindex lists @subentry @code{list} @r{procedure}
@tindex list @subentry @r{constructors} @subentry list
@deftypefn @t{(scheme base)} @/ list obj@dots{}
Returns a newly allocated list consisting of its arguments.

@lisp
(list 'a (+ 3 4) 'c)      @ok{(a 7 c)}
(list)                    @ok{()}
((car (list list)) 'list) @ok{(list)}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ length list
Returns the length of @var{list}.

@lisp
(define circle (circular-list 'x 'y 'z))
(length '(a b c))            @ok{3}
(length '(a (b) (c d e)))    @ok{3}
(length '())                 @ok{0}
(length (cdr (make-list 5))) @ok{4}
(length circle)              @arrow{} @r{@i{infinite loop}} @aside{;; not caught}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ append list@dots{} [obj]
The zero-argument form returns the empty list.  The one-argument form
returns its argument, whatever that argument's type.  Each argument
except the last, if present, must be a list.

With two or more arguments, the returned value consists of the elements
of each list@dots{}, in order (excluding each @var{list}'s terminating
empty list).  A proper list is returned if @var{obj} is a proper list;
an improper list is returned if if @var{obj} is not a proper list.  The
returned value is newly allocated, except that it shares structure with
the last argument, @var{obj}.

@lisp
(append '(x) '(y))       @ok{(x y)}
(append '(a) '(b c d))   @ok{(a b c d)}
(append '(a (b)) '((c))) @ok{(a (b) (c))}
(append '(a b) '(c . d)) @ok{(a b c . d)}
(append '() 'a)          @ok{a}
@end lisp
@lisp
(define l (list 'f 'g 'h))
(eq?    l (append (append) l)) @value{true}
(eq?    l (append l (append))) @value{false}
(equal? l (append l (append))) @value{true}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ reverse list
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order (excluding the terminating empty list).

@lisp
(reverse '(a b c))             @ok{(c b a)}
(reverse '(a (b c) d (e (f)))) @ok{((e (f)) d (b c) a)}
@end lisp
@lisp
(define l (list 'a 'b 'c))
(eq?    l (reverse (reverse l))) @value{false}
(equal? l (reverse (reverse l))) @value{true}
@end lisp
@end deftypefn

@tindex list @subentry @r{selectors} @subentry list-tail
@deftypefn @t{(scheme base)} @/ list-tail list k
Returns a copy of @var{list} obtained by omitting the first @var{k}
elements.  If @var{list} is a proper list, a proper list is returned; if
@var{list} is an improper list, an improper list is returned
(@pxref{Pair and list jargon}).

If @var{k} is not an exact integer, an exception that satisfies
@code{type-exception?} is raised.  If @var{list} has fewer than @var{k}
elements, an exception that satisfies @code{range-exception?} is raised.

@lisp
(list-tail '(a b c) 1)   @ok{(b c)}
(list-tail '(a b c) 3)   @ok{()}
(list-tail '(a b . c) 1) @ok{(b . c)}
(list-tail '(a b . c) 2) @ok{c}
@end lisp
@lisp
(list-tail '(a b c) 1.1) @exception{type}
(list-tail '(a b c) 4)   @exception{range}
@end lisp
@end deftypefn

@tindex list @subentry @r{selectors} @subentry list-ref
@deftypefn @t{(scheme base)} @/ list-ref list k
Returns element @var{k} of @var{list}.  Equivalent to @samp{(car
(list-tail @slanted{list} @slanted{k}))}.  The @var{list} argument may
be circular.

@lisp
(list-ref '(a b c d) 2)                   @ok{c}
(list-ref '(a b c d) (exact (round 1.8))) @ok{c}
@end lisp
@lisp
(list-ref (circular-list 'a 'b) 3) @ok{b} @aside{;; @value{R7RS} says this is an error}
@end lisp
@end deftypefn

@tindex list @subentry @r{mutator} @subentry list-set!
@deftypefn @t{(scheme base)} @/ list-set! list k obj
Mutates @var{list} by storing @var{obj} in element @var{k} of
@var{list}.  It is an error if @var{k} is not a valid index of
@var{list}.

@lisp
(define ls (list 'one 'two 'five!))
(list-set! ls 2 'three)

ls @ok{(one two three)}
@end lisp
@lisp
(list-set! '(0 1 2) 1 "oops") @aside{;; @value{R7RS} says this is an error}
@end lisp
@end deftypefn

@tindex list @subentry @r{selectors} @subentry memq
@tindex list @subentry @r{selectors} @subentry memv
@tindex list @subentry @r{selectors} @subentry member
@deftypefn  @t{(scheme base)} @/ memq   obj list
@deftypefnx @t{(scheme base)} @/ memv   obj list
@deftypefnx @t{(scheme base)} @/ member obj list [compare]
Each procedure successively applies some procedure to each element of
@var{list} and returns the first sublist of @var{list} whose car
satisfies that test relative to @var{obj}.  They differ only in the
procedure that is used.  If no element of @var{list} satisfies the test,
@code{#f} is returned.

In each two-argument form, a standard equivalence predicate is used.  In
the three-argument form of @code{@slanted{member}}, @var{compare} may
return a non-Boolean value.

@itemize @bullet
@item
@code{memq} uses @code{@slanted{eq?}}
@item
@code{memv} uses @code{@slanted{eqv?}}
@item
@code{member} uses @code{@slanted{equal?}} in the two-argument form.
@item
@code{member} uses @var{compare} in the three-argument form.
@end itemize
@lisp
(define nums '(100 101 102))

(memq 101 nums)        @ok{@r{@i{unspecified}}}
(memv 101 nums)        @ok{(101 102)}
(member 7 nums +)      @ok{(100 101 102)}
(member 7 nums square) @exception{wrong number of arguments}

(memq 'a '(a b c))                      @ok{(a b c)}
(memq 'b '(a b c))                      @ok{(b c)}
(memq 'a '(b c d))                      @value{false}
(memq (list 'a) '(b (a) c))             @value{false}
(memq 'a '(a b c))                      @ok{(a b c)}
(member (list 'a) '(b (a) c))           @ok{((a) c)}
(member "B" '("a" "b" "c") string-ci=?) @ok{("b" "c")}
@end lisp
@end deftypefn

@tindex list @subentry @r{selectors} @subentry assq
@tindex list @subentry @r{selectors} @subentry assv
@tindex list @subentry @r{selectors} @subentry assoc
@deftypefn  @t{(scheme base)} @/ assq obj  alist
@deftypefnx @t{(scheme base)} @/ assv obj  alist
@deftypefnx @t{(scheme base)} @/ assoc obj alist [compare]
Each procedure successively applies some procedure to the elements of
@var{alist} returns the first pair of @var{alist} whose car satisfies
that test relative to @var{obj}.  They differ only in the procedure that
is used.  If none of @var{alist}'s elements' cars satisfies the test,
@code{#f} is returned.

In each two-argument form, a standard equivalence predicate is used.  In
the three-argument form of @code{@slanted{assoc}}, @var{compare} may
return a non-Boolean value.

@itemize @bullet
@item
@code{assq} uses @code{@slanted{eq?}}
@item
@code{assv} uses @code{@slanted{eqv?}}
@item
@code{assoc} uses @code{@slanted{equal?}} in the two-argument form.
@item
@code{assoc} uses @var{compare} in the three-argument form.
@end itemize
@lisp
(define e '((a 1) (b 2) (c 3)))

(assq 'a e)                            @ok{(a 1)}
(assq 'b e)                            @ok{(b 2)}
(assq 'd e)                            @value{false}
(assq (list 'a) '(((a)) ((b)) ((c))))  @value{false}
(assoc (list 'a) '(((a)) ((b)) ((c)))) @ok{((a))}
(assoc 2.0 '((1 1) (2 4) (3 9)) =)     @ok{(2 4)}
(assq 5 '((2 3) (5 7) (11 13)))        @ok{@r{unspecified}}
(assv 5 '((2 3) (5 7) (11 13)))        @ok{(5 7)}
@end lisp
@end deftypefn

@tindex list @subentry @r{constructors} @subentry list-copy
@deftypefn @t{(scheme base)} @/ list-copy obj
Returns a newly allocated copy of the given @var{obj} if it is a list.
Only the pairs themselves are copied; the cars of the result are the
same (in the sense of @code{eqv?}) as the cars of @var{list}.  If
@var{obj} is an improper list, so is the result, and the final cdrs are
the same in the sense of @code{eqv?}.  An @var{obj} which is not a list
is returned unchanged.  It is an error if @var{obj} is a circular list.

@lisp
(define a '(1 8 2 8))    @aside{;; a may be immutable}
(define b (list-copy a))
(set-car! b 3)           @aside{;; b is mutable}

b @ok{(3 8 2 8)}
a @ok{(1 8 2 8)}
@end lisp
@lisp
(define circle (circular-list 0 1 2 3))
(list-copy circle) @arrow{} @r{@i{infinite loop}} @aside{;; not caught}
@end lisp
@end deftypefn
