@node Pairs and list procedures
@chapter Pair and list procedures

@deftypefn @t{(scheme base)} @/ pair? obj
Returns @code{#t} if @var{obj} is a pair.

@lisp
(pair? '(a . b)) @result{} #t
(pair? '(a b c)) @result{} #t
(pair? '())      @result{} #f
(pair? '(() ())) @result{} #f
(pair? '#(a b))  @result{} #f
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ cons @pari{obj} @parii{obj}
Returns a newly allocated pair whose car is @vari{obj} and whose cdr is
@varii{obj}.  The pair is guaranteed to be different (in the sense of
@code{eqv?}) from every existing object.

@lisp
(cons 'a '())                      @result{} (a)
(cons '(a) '(b c d))               @result{} ((a) b c d)
(cons "a" '(b c))                  @result{} ("a" b c)
(cons 'a 3)                        @result{} (a . 3)
(cons '(a b) 'c)                   @result{} ((a b) . c)
(eq? cons (cdr (cons cons cons)))  @result{} #t
(eqv?   (cons + car) (cons + car)) @result{} #f
(equal? (cons + car) (cons + car)) @result{} #t
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ car pair
@tindex empty list
Returns the contents of the cdr field of @var{pair}.  If an attempt is
made to take the car of the empty list, an exception that satisfies
@code{type-exception?} is raised.

@lisp
(car '(a b c))     @result{} a
(car '((a) b c d)) @result{} (a)
(car '(1 . 2))     @result{} 1
(car '())          @exception{type}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ cdr pair
Returns the contents of the cdr field of @var{pair}.  If an attempt is
made to take the cdr of the empty list, an exception that satisfies
@code{type-exception?} is raised.

@lisp
(cdr '(a b c))     @result{} (b c)
(cdr '((a) b c d)) @result{} (b c d)
(cdr '(1 . 2))     @result{} 2
(cdr '())          @exception{type}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ set-car! pair obj
Mutates @var{pair} by storing @var{obj} in the car field of @var{pair}.

@lisp
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))

(set-car! (f) 3) @slanted{;; legal, but useless}
(f)              @result{} (not-a-constant-list)
(set-car! (g) 3) @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ set-cdr! pair obj
Mutates @var{pair} by storing @var{obj} in the cdr field of @var{pair}.

@lisp
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))

(set-cdr! (f) 3) @slanted{;; legal, but useless}
(f)              @result{} (not-a-constant-list)
(set-cdr! (g) 3) @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn  @t{(scheme cxr)} @/ caar pair
@deftypefnx @t{(scheme cxr)} @/ cadr pair
@deftypefnx @t{(scheme cxr)} @/ cdar pair
@deftypefnx @t{(scheme cxr)} @/ cddr pair
@deftypefnx @t{(scheme cxr)} @/ caaar pair
@deftypefnx @t{(scheme cxr)} @/ caadr pair
@deftypefnx @t{(scheme cxr)} @/ cadar pair
@deftypefnx @t{(scheme cxr)} @/ caddr pair
@deftypefnx @t{(scheme cxr)} @/ cdaar pair
@deftypefnx @t{(scheme cxr)} @/ cdadr pair
@deftypefnx @t{(scheme cxr)} @/ cddar pair
@deftypefnx @t{(scheme cxr)} @/ cdddr pair
@deftypefnx @t{(scheme cxr)} @/ caaaar pair
@deftypefnx @t{(scheme cxr)} @/ caaadr pair
@deftypefnx @t{(scheme cxr)} @/ caadar pair
@deftypefnx @t{(scheme cxr)} @/ caaddr pair
@deftypefnx @t{(scheme cxr)} @/ cadaar pair
@deftypefnx @t{(scheme cxr)} @/ cadadr pair
@deftypefnx @t{(scheme cxr)} @/ caddar pair
@deftypefnx @t{(scheme cxr)} @/ cadddr pair
@deftypefnx @t{(scheme cxr)} @/ cdaaar pair
@deftypefnx @t{(scheme cxr)} @/ cdaadr pair
@deftypefnx @t{(scheme cxr)} @/ cdadar pair
@deftypefnx @t{(scheme cxr)} @/ cdaddr pair
@deftypefnx @t{(scheme cxr)} @/ cddaar pair
@deftypefnx @t{(scheme cxr)} @/ cddadr pair
@deftypefnx @t{(scheme cxr)} @/ cdddar pair
@deftypefnx @t{(scheme cxr)} @/ cddddr pair

These procedures are compositions of @code{car} and @code{cdr}.

@lisp
(define l '((a b) (c) d (e (f) g)))
(define circle (circular-list 'a 'b 'c))

(cadr l)             @result{} (c)
(car (cdr l))        @result{} (c)
(cddr '(a b c . d))  @result{} (c . d)
(cdddr '(a b c . d)) @result{} d
(cdadr l)            @result{} ()
(cdar (cdr l))       @result{} ()
(caar (cdr l))       @result{} c
(car (car (cdr l)))  @result{} c
(cadddr l)           @result{} (e (f) g)
(caaadr l)           @exception{type}

(car circle)         @result{} a
(cadr circle)        @result{} b
(caddr circle)       @result{} c
(cadddr circle)      @result{} a
@end lisp
@end deftypefn

@cindex empty list
@deftypefn @t{(scheme base)} @/ null? obj
Returns @code{#t} if @var{obj} is the empty list.

@lisp
(null? '())    @result{} #t
(null? (list)) @result{} #t
(null? #\null) @result{} #f
(null? null?)  @result{} #f
(null? #f)     @result{} #f
(null? 0)      @result{} #f
(null? "")     @result{} #f
(null? #())    @result{} #f
(null? (void)) @result{} #f
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list? obj
Returns @code{#t} if @var{obj} is a list (sometimes referred to as a
@dfn{proper list}).  By definition, a list of finite length is
terminated by the empty list.

@lisp
(list? '(a b c))     @result{} #t
(list? '())          @result{} #t
(list? '(a . b))     @result{} #f
(let ((x (list 'a)))
  (set-cdr! x x)
  (list? x))         @result{} #f
(list? list)         @result{} #f
(list? "list")       @result{} #f
(list? #(0 1 2))     @result{} #f
@end lisp
@end deftypefn

@deftypefn  @t{(scheme base)} @/ make-list k
@deftypefnx @t{(scheme base)} @/ make-list k fill
Returns a newly allocated list of @var{k} elements.  In the one-argument
form, each element is initialized to a default value.  In the
two-argument form, each element is initialized to the value of
@var{fill}.

The default value used by the one-argument form may change in a future
version.  Programs that require a specific initilization value should
use the two-argument form.

@lisp
(make-list 0)        @result{} ()
(make-list 3 (list)) @result{} (() () ())
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list obj@dots{}
Returns a newly allocated list consisting of its arguments.

@lisp
(list 'a (+ 3 4) 'c)      @result{} (a 7 c)
(list)                    @result{} ()
((car (list list)) 'list) @result{} (list)
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ length list
Returns the length of @var{list}.

@lisp
(define circle (circular-list 'x 'y 'z))

(length '(a b c))            @result{} 3
(length '(a (b) (c d e)))    @result{} 3
(length '())                 @result{} 0
(length (cdr (make-list 5))) @result{} 4
(length circle)              @arrow{} @i{infinite loop}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ append list@dots{} [obj]
The zero-argument form returns the empty list.  The one-argument form
returns its argument, whatever that argument's type.  Each argument
except the last, if present, must be a list.

With two or more arguments, the returned value consists of the elements
of each list@dots{}, in order (excluding each @var{list}'s terminating
empty list).  A list is returned if @var{obj} is a list; an improper
list is returned if if @var{obj} is not a list.  The returned value is
newly allocated, except that it shares structure with the last argument,
@var{obj}.

@lisp
(define l (list 'f 'g 'h))

(eq?    l (append (append) l)) @result{} #t
(eq?    l (append l (append))) @result{} #f
(equal? l (append l (append))) @result{} #t

(append '(x) '(y))              @result{} (x y)
(append '(a) '(b c d))          @result{} (a b c d)
(append '(a (b)) '((c)))        @result{} (a (b) (c))

(append '(a b) '(c . d))        @result{} (a b c . d)
(append '() 'a)                 @result{} a
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ reverse list
Returns a newly allocated list consisting of the elements of @var{list}
in reverse order (excluding the terminating empty list).

@lisp
(define l (list 'a 'b 'c))

(eq?    l (reverse (reverse l))) @result{} #f
(equal? l (reverse (reverse l))) @result{} #t

(reverse '(a b c))             @result{} (c b a)
(reverse '(a (b c) d (e (f)))) @result{} ((e (f)) d (b c) a)
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-tail list k
Returns the sublist of @var{list} obtained by omitting the first
@var{k} elements. The @code{list-tail} procedure could be defined by

It is an error if @var{list} has fewer than @var{k} elements.

@lisp
(define l '(a b c))

(list-tail l 1) @result{} (b c)
(list-tail l 3) @result{} ()
(list-tail l 4) @exception{range}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-ref list k
Returns element @var{k} of @var{list}.  Equivalent to @samp{(car
(list-tail @slanted{list} @slanted{k}))}.  The @var{list} argument may
be circular.

@lisp
(list-ref '(a b c d) 2)                   @result{} c
(list-ref '(a b c d) (exact (round 1.8))) @result{} c
(list-ref (circular-list 'a 'b 'c) 4) @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn @t{(scheme base)} @/ list-set! list k obj
Mutates @var{list} by storing @var{obj} in element @var{k} of
@var{list}.  It is an error if @var{k} is not a valid index of
@var{list}.

@lisp
(let ((ls (list 'one 'two 'five!)))
  (list-set! ls 2 'three)
  ls) @result{} (one two three)

(list-set! '(0 1 2) 1 "oops") @slanted{;; r7rs says this is an error}
@end lisp
@end deftypefn

@deftypefn  @t{(scheme base)} @/ memq obj list
@deftypefnx @t{(scheme base)} @/ memv obj list
@deftypefnx @t{(scheme base)} @/ member obj list [compare]
Each procedure successively applies some procedure to the elements of
@var{list} returns the first sublist of @var{list} whose car satisfies
that test relative to @var{obj}.  They differ only in the procedure that
is used.  If no element of @var{list} satisfies the test, @code{#f} is
returned.

In each two-argument form, a standard equivalence predicate is used.  In
the three-argument form of @code{@slanted{member}}, @var{compare} may
return a non-Boolean value.

@itemize @bullet
@item
@code{memq} uses @code{@slanted{eq?}}
@item
@code{memv} uses @code{@slanted{eqv?}}
@item
@code{member} uses @code{@slanted{equal?}} in the two-argument form.
@item
@code{member} uses @var{compare} in the three-argument form.
@end itemize

@lisp
(memq 'a '(a b c))                      @result{} (a b c)
(memq 'b '(a b c))                      @result{} (b c)
(memq 'a '(b c d))                      @result{} #f
(memq (list 'a) '(b (a) c))             @result{} #f
(memq 101 '(100 101 102))               @result{} @r{@i{unspecified}}
(memv 101 '(100 101 102))               @result{} (101 102)
(memq 'a '(a b c))                      @result{} (a b c)
(member (list 'a) '(b (a) c))           @result{} ((a) c)
(member 7 '(0 1 2 3) +)                 @result{} (0 1 2 3)
(member 7 '(0 1 2 3) square)            @exception{wrong number of arguments}
(member "B" '("a" "b" "c") string-ci=?) @result{} ("b" "c")
@end lisp
@end deftypefn

@c @deffn  procedure assq obj alist
@c @deffnx procedure assv obj alist
@c @deffnx procedure assoc obj alist
@c @deffnx procedure assoc obj alist compare

@c It is an error if @var{alist} (for ``association list'') is not a list
@c of pairs.

@c These procedures find the first pair in @var{alist} whose car field
@c is @var{obj}, and returns that pair.  If no pair in @var{alist} has
@c @var{obj} as its car, then @code{#f} (not the empty list) is returned.
@c The @code{assq} procedure uses @code{eq?} to compare @var{obj} with the
@c car fields of the pairs in @var{alist}, while @code{assv} uses @code{eqv?}
@c and @code{assoc} uses @var{compare} if given and @code{equal?} otherwise.

@c @lisp
@c (define e '((a 1) (b 2) (c 3)))
@c (assq 'a e)                            @result{} (a 1)
@c (assq 'b e)                            @result{} (b 2)
@c (assq 'd e)                            @result{} #f
@c (assq (list 'a) '(((a)) ((b)) ((c))))  @result{} #f
@c (assoc (list 'a) '(((a)) ((b)) ((c)))) @result{} ((a))
@c (assoc 2.0 '((1 1) (2 4) (3 9)) =)     @result{} (2 4)
@c (assq 5 '((2 3) (5 7) (11 13)))        @result{} @r{unspecified}
@c (assv 5 '((2 3) (5 7) (11 13)))        @result{} (5 7)
@c @end lisp

@c @end deffn
@c @deffn procedure list-copy obj

@c Returns a newly allocated copy of the given @var{obj} if it is a list.
@c Only the pairs themselves are copied; the cars of the result are the same
@c (in the sense of @code{eqv?}) as the cars of @var{list}.  If @var{obj}
@c is an improper list, so is the result, and the final cdrs are the same in
@c the sense of @code{eqv?}.  An @var{obj} which is not a list is returned
@c unchanged.  It is an error if @var{obj} is a circular list.

@c @lisp
@c (define a '(1 8 2 8)) ; a may be immutable
@c (define b (list-copy a))
@c (set-car! b 3)        ; b is mutable
@c b @result{} (3 8 2 8)
@c a @result{} (1 8 2 8)
@c @end lisp

@c @end deffn
