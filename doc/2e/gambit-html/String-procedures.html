<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- This is the Gambit Scheme manual, revised edition.  It documents
Gambit v4.9.5 (September 20, 2024).

Not officially copyright Â© 1994-2024 by Marc Feeley et al.

The Gambit system, version 4.9.5, is licensed under two
licenses: the https://www.apache.org/licenses/ (Apache License, version 2.0), and the https://www.gnu.org/licenses/ (GNU Lesser General Public License, version 2.1).  You may choose
which of these two licenses to abide by.
 -->
<title>String procedures (Gambit Scheme, revised edition)</title>

<meta name="description" content="String procedures (Gambit Scheme, revised edition)">
<meta name="keywords" content="String procedures (Gambit Scheme, revised edition)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2any">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="General-Index.html" rel="index" title="General Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Strings.html" rel="up" title="Strings">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
body {color: #000000; background-color: #fbf7f0}
a:link {color: #3548cf}
a:visited {color: #721045}
hr {color: #9f9690}
.chapter-level-extent pre {background-color: #efe9dd; border-color: #9f9690}

dl,first-deftp, dl.first-deftypefn {
    .i {color: #624416}
    dt span.category-def {color: #595959}
    dd pre {
        .code {color: #63192a}
        .slanted {color: #595959}
        .t {color: #193668}
    }
}

dl.first-deftypefn {
    dt code.def-code-arguments, dd p var {color: #721045}
}

dd, .center, li, ol, p:not(.nav-panel p) {max-width: 40em}

.chapter-level-extent dd {
    p:not(.nav-panel p) {text-align: justify}
    pre {border-style: solid; padding: 0.3236em 0.2em}
}

-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="String-procedures">
<div class="nav-panel">
<p>
Up: <a href="Strings.html" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section chapter-level-set-section" id="String-procedures-1"><span>5.1 String procedures<a class="copiable-link" href="#String-procedures-1"> &para;</a></span></h3>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_003f"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string?</strong> <code class="def-code-arguments">obj</code><a class="copiable-link" href="#index-string_003f"> &para;</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is a string.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string? &quot;&quot;)                     &rArr; <code class="t">#t</code>
(string? #\a)                    &rArr; <code class="code">#f</code>
(string? &quot;a&quot;)                    &rArr; <code class="t">#t</code>
(string? 'string)                &rArr; <code class="code">#f</code>
(string? '(#\c #\h #\a #\r #\s)) &rArr; <code class="code">#f</code>
(string? #(#\c #\h #\a #\r #\s)) &rArr; <code class="code">#f</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-make_002dstring"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">make-string</strong> <code class="def-code-arguments">k [char]</code><a class="copiable-link" href="#index-make_002dstring"> &para;</a></span></dt>
<dd><p>Returns a newly allocated string of length <var class="var">k</var>.  In the one-argument
form, each character is initialized to a default value.  In the
two-argument form, each character is initialized to <var class="var">char</var>.
</p>
<p>The default value used by the one-argument form may change in a future
version.  Programs that require a specific initialization value should
use the two-argument form.
</p>
<p>If <var class="var">k</var> is not an exact integer, an exception that satisfies
<code class="code">type-exception?</code> is raised.  If <var class="var">k</var> is a negative exact
integer, an exception that satisfies <code class="code">range-exception?</code> is raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make-string 0)                 &rArr; <code class="t">&quot;&quot;</code>
(string-length (make-string 4)) &rArr; <code class="t">4</code>
(make-string 4 #\g)             &rArr; <code class="t">&quot;gggg&quot;</code>
(make-string 4 &quot;g&quot;)             &rarr; <span class="r"><i class="i">type exception</i></span>
(make-string 4.5)               &rarr; <span class="r"><i class="i">type exception</i></span>
(make-string -1)                &rarr; <span class="r"><i class="i">range exception</i></span>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string</strong> <code class="def-code-arguments">char&hellip;</code><a class="copiable-link" href="#index-string"> &para;</a></span></dt>
<dd><p>Returns a newly allocated string whose elements are its arguments.  The
order of the arguments is preserved.  Analogous to <code class="code">list</code>
(see <a class="pxref" href="Pair-and-list-procedures.html">Pair and list procedures</a>).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string)                         &rArr; <code class="t">&quot;&quot;</code>
(string #\G #\a #\m #\b #\i #\t) &rArr; <code class="t">&quot;Gambit&quot;</code>
(string (string-&gt;list &quot;Gambit&quot;)) &rArr; <code class="t">&quot;Gambit&quot;</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dlength"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-length</strong> <code class="def-code-arguments">[string]</code><a class="copiable-link" href="#index-string_002dlength"> &para;</a></span></dt>
<dd><p>Returns the number of characters in <var class="var">string</var>.
</p><div class="example lisp">
<pre class="lisp-preformatted">(string-length (make-string 5)) &rArr; <code class="t">5</code>
(string-length &quot;&quot;)              &rArr; <code class="t">0</code>
(string-length &quot;lambda&quot;)        &rArr; <code class="t">6</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dref"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-ref</strong> <code class="def-code-arguments">string k</code><a class="copiable-link" href="#index-string_002dref"> &para;</a></span></dt>
<dd><p>Returns the character at index <var class="var">k</var> of <var class="var">string</var>.  If <var class="var">k</var> is
not a valid index of <var class="var">string</var>, an exception that satisfies
<code class="code">range-exception?</code> is raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define s &quot;off by one&quot;)

(string-ref &quot;zero-origin indexing&quot; 0)  &rArr; <code class="t">#\z</code>
(string-ref s (- (string-length s) 1)) &rArr; <code class="t">#\e</code>
(string-ref s (string-length s))       &rarr; <span class="r"><i class="i">range exception</i></span>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_003d_003f"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string=?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_003d_003f"> &para;</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if all the <var class="var">strings</var> are the same length and
contain exactly the same characters in the same positions, otherwise
returns <code class="code">#f</code>.
</p>
<p>Gambit extends the <abbr class="acronym">R<sup class="sup">7</sup>RS</abbr> description of <code class="code">string=?</code> to accept
any number of arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string=? &quot;abc&quot; (string #\a #\b #\c)) &rArr; <code class="t">#t</code>
(string=? &quot;abcd&quot; &quot;Abcd&quot;)              &rArr; <code class="code">#f</code>
(string=?)                            &rArr; <code class="t">#t</code>
(string=? &quot;a&quot; &quot;a&quot; &quot;a&quot;)                &rArr; <code class="t">#t</code>
(string=? &quot;a&quot; #\a)                    &rarr; <span class="r"><i class="i">type exception</i></span>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_003c_003f"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string&lt;?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_003c_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_003e_003f"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string&gt;?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_003e_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_003c_003d_003f"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string&lt;=?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_003c_003d_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_003e_003d_003f"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string&gt;=?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_003e_003d_003f"> &para;</a></span></dt>
<dd><p>These predicates return <code class="code">#t</code> if their arguments are (respectively):
monotonically increasing, monotonically decreasing, monotonically
non-decreasing, or monotonically non-increasing.  They are transitive.
</p>
<p>A pair of strings satisfies exactly one of <code class="code">string&lt;?</code>,
<code class="code">string=?</code>, and <code class="code">string&gt;?</code>.  They may satisfy <code class="code">string&lt;=?</code>
if and only if they do not satisfy <code class="code">string&gt;?</code>.  They may satisfy
<code class="code">string&gt;=?</code> if and only if they do not satisfy <code class="code">string&lt;?</code>.
</p>
<p>Gambit extends the <abbr class="acronym">R<sup class="sup">7</sup>RS</abbr> descriptions of these procedures to
accept any number of arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string&lt;=? &quot;g&quot; &quot;g&quot;) &rArr; <code class="code">#f</code>
(string&gt;=? &quot;g&quot; &quot;g&quot;) &rArr; <code class="code">#f</code>
(string&lt;?  &quot;g&quot; &quot;g&quot;) &rArr; <code class="code">#f</code>
(string&gt;?  &quot;g&quot; &quot;g&quot;) &rArr; <code class="code">#f</code>

(string&lt;? &quot;G&quot; &quot;g&quot;)  &rArr; <code class="t">#t</code>
(string&gt;? &quot;G&quot; &quot;g&quot;)  &rArr; <code class="code">#f</code>

(string&lt;? &quot;gg&quot; &quot;g&quot;) &rArr; <code class="code">#f</code>
(string&gt;? &quot;gg&quot; &quot;g&quot;) &rArr; <code class="t">#t</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dci_003d_003f"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-ci=?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_002dci_003d_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_002dci_003c_003f"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-ci&lt;?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_002dci_003c_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_002dci_003e_003f"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-ci&gt;?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_002dci_003e_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_002dci_003c_003d_003f"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-ci&lt;=?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_002dci_003c_003d_003f"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_002dci_003e_003d_003f"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-ci&gt;=?</strong> <code class="def-code-arguments">[string&hellip;]</code><a class="copiable-link" href="#index-string_002dci_003e_003d_003f"> &para;</a></span></dt>
<dd><p>Each of these predicates behaves as if <code class="code">string-foldcase</code> were
applied to each of its arguments, and then that predicate&rsquo;s
non-&lsquo;<samp class="samp">-ci</samp>&rsquo; counterpart were applied to those case-folded arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-ci=?  &quot;G&quot; &quot;g&quot;)  &rArr; <code class="t">#t</code>
(string-ci&lt;=? &quot;G&quot; &quot;g&quot;)  &rArr; <code class="code">#f</code>

(string-ci&lt;?  &quot;G&quot; &quot;g&quot;)  &rArr; <code class="code">#f</code>
(string-ci&gt;?  &quot;G&quot; &quot;g&quot;)  &rArr; <code class="code">#f</code>

(string-ci&lt;?  &quot;gg&quot; &quot;g&quot;) &rArr; <code class="code">#f</code>
(string-ci&gt;?  &quot;gg&quot; &quot;g&quot;) &rArr; <code class="t">#t</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dupcase"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-upcase</strong> <code class="def-code-arguments">string</code><a class="copiable-link" href="#index-string_002dupcase"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_002ddowncase"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-downcase</strong> <code class="def-code-arguments">string</code><a class="copiable-link" href="#index-string_002ddowncase"> &para;</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-string_002dfoldcase"><span class="category-def"><code class="t">(scheme char)</code>: </span><span><strong class="def-name">string-foldcase</strong> <code class="def-code-arguments">string</code><a class="copiable-link" href="#index-string_002dfoldcase"> &para;</a></span></dt>
<dd><p>These procedures apply the Unicode full string uppercasing, lowercasing,
and case-folding algorithms to their arguments and return the result.
In certain cases, the result differs in length from <var class="var">string</var>.  Note
that language-sensitive mappings and foldings are not used.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-downcase &quot;Wei&szlig;&quot;)  &rArr; <code class="t">&quot;wei&szlig;&quot;</code>
(string-foldcase &quot;Wei&szlig;&quot;)  &rArr; <code class="t">&quot;weiss&quot;</code>
(string-upcase   &quot;Wei&szlig;&quot;)  &rArr; <code class="t">&quot;WEISS&quot;</code>

(string-downcase &quot;WEISS&quot;) &rArr; <code class="t">&quot;weiss&quot;</code>
(string-foldcase &quot;WEISS&quot;) &rArr; <code class="t">&quot;weiss&quot;</code>

(string-downcase &quot;&#x0388;&#x03C4;&#x03BF;&#x03C2;&quot;)  &rArr; <code class="t">&quot;&#x03AD;&#x03C4;&#x03BF;&#x03C2;&quot;</code>
(string-foldcase &quot;&#x0388;&#x03C4;&#x03BF;&#x03C2;&quot;)  &rArr; <code class="t">&quot;&#x03AD;&#x03C4;&#x03BF;&#x03C3;&quot;</code>
(string-upcase   &quot;&#x0388;&#x03C4;&#x03BF;&#x03C2;&quot;)  &rArr; <code class="t">&quot;&#x0388;&#x03A4;&#x039F;&#x03A3;&quot;</code>

(string-downcase &quot;&#x0388;&#x03A4;&#x039F;&#x03A3;&quot;)  &rArr; <code class="t">&quot;&#x03AD;&#x03C4;&#x03BF;&#x03C3;&quot;</code>
(string-foldcase &quot;&#x0388;&#x03A4;&#x039F;&#x03A3;&quot;)  &rArr; <code class="t">&quot;&#x03AD;&#x03C4;&#x03BF;&#x03C3;&quot;</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dappend"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-append</strong> <code class="def-code-arguments">string&hellip;</code><a class="copiable-link" href="#index-string_002dappend"> &para;</a></span></dt>
<dd>
<p>Returns a newly allocated string whose characters are the concatenation
of the characters in the given <var class="var">strings</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-append)                     &rArr; <code class="t">&quot;&quot;</code>
(string-append &quot;&quot;)                  &rArr; <code class="t">&quot;&quot;</code>
(string-append &quot;hello&quot; &quot;world&quot;)     &rArr; <code class="t">&quot;helloworld&quot;</code>
(string-append &quot;hello&quot; &quot;&quot; &quot;world&quot;)  &rArr; <code class="t">&quot;helloworld&quot;</code>
(string-append &quot;hello &quot; &quot; world&quot;)   &rArr; <code class="t">&quot;hello  world&quot;</code>
(string-append &quot;hello&quot; &quot; &quot; &quot;world&quot;) &rArr; <code class="t">&quot;hello world&quot;</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002d_003elist"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-&gt;list</strong> <code class="def-code-arguments">string [start [end]]</code><a class="copiable-link" href="#index-string_002d_003elist"> &para;</a></span></dt>
<dd><p>Returns a newly allocated list of characters in <var class="var">string</var>.  In the
one-argument form, the returned list comprises all characters of
<var class="var">string</var>.  In the two-argument form, the returned list comprises
characters from index <var class="var">start</var> (inclusive) through the end of
<var class="var">string</var>.  In the three-argument form, the returned list comprises
characters from index <var class="var">start</var> (inclusive) through index <var class="var">end</var>
(exclusive).
</p>
<p>Order is preserved.  <code class="code">string-&gt;list</code> and <code class="code">list-&gt;string</code> are
inverses so far as <code class="code">equal?</code> is concerned.  If either <var class="var">start</var> or
<var class="var">end</var> is not a valid index of <var class="var">string</var>, an exception that
satisfies <code class="code">range-exception?</code> is raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-&gt;list &quot;scheme&quot;)     &rArr; <code class="t">(#\s #\c #\h #\e #\m #\e)</code>
(string-&gt;list &quot;scheme&quot; 1)   &rArr; <code class="t">(#\c #\h #\e #\m #\e)</code>
(string-&gt;list &quot;scheme&quot; 2 6) &rArr; <code class="t">(#\h #\e #\m #\e)</code>
(string-&gt;list &quot;scheme&quot; 6)   &rArr; <code class="t">()</code>
(string-&gt;list &quot;scheme&quot; 6 6) &rArr; <code class="t">()</code>
(string-&gt;list &quot;scheme&quot; 7)   &rarr; <span class="r"><i class="i">range exception</i></span>
(string-&gt;list &quot;scheme&quot; 3 7) &rarr; <span class="r"><i class="i">range exception</i></span>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-list_002d_003estring"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">list-&gt;string</strong> <code class="def-code-arguments">list</code><a class="copiable-link" href="#index-list_002d_003estring"> &para;</a></span></dt>
<dd><p>Returns a newly allocated string formed from the elements in <var class="var">list</var>.
</p>
<p>Order is preserved.  <code class="code">list-&gt;string</code> and <code class="code">string-&gt;list</code> and are
inverses so far as <code class="code">equal?</code> is concerned.  If any element of
<var class="var">list</var> is not a character, an exception that satisfies <code class="code">type?</code>
is raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(list-&gt;string (list))                       &rArr; <code class="t">&quot;&quot;</code>
(list-&gt;string '(#\s #\c #\h #\e #\m #\e))   &rArr; <code class="t">&quot;scheme&quot;</code>
(list-&gt;string '(#\s #\c #\h #\e #\m #\e 2)) &rarr; <span class="r"><i class="i">type exception</i></span>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dcopy"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-copy</strong> <code class="def-code-arguments">[start [end]]</code><a class="copiable-link" href="#index-string_002dcopy"> &para;</a></span></dt>
<dd><p>Returns a newly allocated string whose value is a portion of
<var class="var">string</var>.  In the one-argument form, the returned portion is all of
<var class="var">string</var>.  In the two-argument form, the returned string is a copy
of <var class="var">string</var> from index <var class="var">start</var> (inclusive) through the end of
<var class="var">string</var>.  In the three-argument form, the returned string is a copy
of <var class="var">string</var> from index <var class="var">start</var> (inclusive) to index <var class="var">end</var>
(exclusive).
</p>
<p>Order is preserved.  <code class="code">string-&gt;list</code> and <code class="code">list-&gt;string</code> and are
inverses so far as <code class="code">equal?</code> is concerned.  If either <var class="var">start</var> or
<var class="var">end</var> is not a valid index of <var class="var">string</var>, an exception that
satisfies <code class="code">range-exception?</code> is raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define s &quot;dwim&quot;)

(string-copy s)                     &rArr; <code class="t">&quot;dwim&quot;</code>
(string-copy s 1)                   &rArr; <code class="t">&quot;wim&quot;</code>
(string-copy s 1 1)                 &rArr; <code class="t">&quot;&quot;</code>
(string-copy s 0 (string-length s)) &rArr; <code class="t">&quot;dwim&quot;</code>
(eqv?     s (string-copy s))        &rArr; <code class="code">#f</code>
(string=? s (string-copy s))        &rArr; <code class="t">#t</code>
(string-copy s 6)                   &rarr; <span class="r"><i class="i">range exception</i></span>
(string-copy s -1 3)                &rarr; <span class="r"><i class="i">range exception</i></span>
(string-copy s 2 5)                 &rarr; <span class="r"><i class="i">range exception</i></span>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dcopy_0021"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-copy!</strong> <code class="def-code-arguments">to-string at from-string [start [end]]</code><a class="copiable-link" href="#index-string_002dcopy_0021"> &para;</a></span></dt>
<dd>
<p>Mutates <var class="var">to-string</var> by copying a substring of <var class="var">from-string</var> into
<var class="var">to-string</var>, beginning with index <var class="var">at</var> of <var class="var">to-string</var>.  In
the three-argument form, all of <var class="var">from-string</var> is copied.  In the
four-argument form, the value of &lsquo;<samp class="samp">(string-copy
<i class="slanted">from-string</i> <i class="slanted"><var class="var">start</var></i>)</samp>&rsquo; is copied.  In the
five-argument form, the value of &lsquo;<samp class="samp">(string-copy
<i class="slanted">from-string</i> <i class="slanted"><var class="var">start</var></i> <i class="slanted"><var class="var">end</var></i>)</samp>&rsquo; is
copied.
</p>
<p>If <var class="var">at</var> is not a valid index of <var class="var">to-string</var>, an exception that
satisfies <code class="code">range-exception?</code> is raised.  If &lsquo;<samp class="samp">(- (string-length
<i class="slanted">to-string</i>) <i class="slanted">at</i>)</samp>&rsquo; is less than &lsquo;<samp class="samp">(- <i class="slanted">end</i>
<i class="slanted">start</i>)</samp>&rsquo;, an exception that satisfies <code class="code">range-exception?</code>
is raised (in other words, the copied substring must not overflow beyond
the end of <var class="var">to-string</var>).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define a &quot;12345&quot;)
(define b (string-copy &quot;abcde&quot;))

(string-copy! b 1 a 0 2)
b &rArr; <code class="t">&quot;a12de&quot;</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dfill_0021"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-fill!</strong> <code class="def-code-arguments">string char [start [end]]</code><a class="copiable-link" href="#index-string_002dfill_0021"> &para;</a></span></dt>
<dd><p>Mutates <var class="var">string</var> by overwriting some or all of its elements with
<var class="var">char</var>.  In the two-argument form, each element is overwritten.  In
the three-argument form, the elements from index <var class="var">start</var> (inclusive)
through the end of <var class="var">string</var> are overwritten.  In the four-argument
form, the elements from index <var class="var">start</var> (inclusive) to index <var class="var">end</var>
(exclusive) are overwritten.
</p>
<p>If either <var class="var">start</var> or <var class="var">end</var> is not a valid index of <var class="var">string</var>,
an exception that satisfies <code class="code">range-exception?</code> is raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define a (string-copy &quot;abcde&quot;))
(define b (string-copy a))
(define c (string-copy b))

(string-fill! a #\0)
(string-fill! b #\0 3)
(string-fill! c #\0 3 4)

a &rArr; <code class="t">&quot;00000&quot;</code>
b &rArr; <code class="t">&quot;abc00&quot;</code>
c &rArr; <code class="t">&quot;abc0e&quot;</code>
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dset_0021"><span class="category-def"><code class="t">(scheme base)</code>: </span><span><strong class="def-name">string-set!</strong> <code class="def-code-arguments">string k char</code><a class="copiable-link" href="#index-string_002dset_0021"> &para;</a></span></dt>
<dd><p>Mutates <var class="var">string</var> by storing <var class="var">char</var> in element <var class="var">k</var> of
<var class="var">string</var>.
</p>
<p>If <var class="var">string</var> is not a mutable string, an exception that satisfies
<code class="code">type-exception?</code> is raised.  If <var class="var">k</var> is not a valid index of
<var class="var">string</var>, an exception that satisfies <code class="code">range-exception?</code> is
raised.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (f) (make-string 3 #\*))
(define (g) &quot;***&quot;)

(string-set! (f) 0 #\?) <i class="slanted">;; legal, but useless</i>
(string-set! (g) 0 #\?) <i class="slanted">;; r7rs says this is an error</i>
(string-set! (symbol-&gt;string 'immutable) 0 #\?) &rarr; <span class="r"><i class="i">type exception</i></span>
(string-set! (f) 5 #\?)                         &rarr; <span class="r"><i class="i">range exception</i></span>
</pre></div>
</dd></dl>

</div>
<hr>
<div class="nav-panel">
<p>
Up: <a href="Strings.html">Strings</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="General-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
